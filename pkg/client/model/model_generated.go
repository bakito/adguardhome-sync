// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package model

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for CheckConfigStaticIpInfoStatic.
const (
	CheckConfigStaticIpInfoStaticError CheckConfigStaticIpInfoStatic = "error"
	CheckConfigStaticIpInfoStaticNo    CheckConfigStaticIpInfoStatic = "no"
	CheckConfigStaticIpInfoStaticYes   CheckConfigStaticIpInfoStatic = "yes"
)

// Defines values for DNSConfigBlockingMode.
const (
	CustomIp DNSConfigBlockingMode = "custom_ip"
	Default  DNSConfigBlockingMode = "default"
	NullIp   DNSConfigBlockingMode = "null_ip"
	Nxdomain DNSConfigBlockingMode = "nxdomain"
	Refused  DNSConfigBlockingMode = "refused"
)

// Defines values for DNSConfigUpstreamMode.
const (
	MapConstDeprecatedTrueDescriptionUseloadBalanceInstead DNSConfigUpstreamMode = "map[const: deprecated:true description:Use `load_balance` instead.]"
	MapConstFastestAddr                                    DNSConfigUpstreamMode = "map[const:fastest_addr]"
	MapConstLoadBalance                                    DNSConfigUpstreamMode = "map[const:load_balance]"
	MapConstParallel                                       DNSConfigUpstreamMode = "map[const:parallel]"
)

// Defines values for DhcpSearchResultOtherServerFound.
const (
	DhcpSearchResultOtherServerFoundError DhcpSearchResultOtherServerFound = "error"
	DhcpSearchResultOtherServerFoundNo    DhcpSearchResultOtherServerFound = "no"
	DhcpSearchResultOtherServerFoundYes   DhcpSearchResultOtherServerFound = "yes"
)

// Defines values for DhcpSearchResultStaticIPStatic.
const (
	DhcpSearchResultStaticIPStaticError DhcpSearchResultStaticIPStatic = "error"
	DhcpSearchResultStaticIPStaticNo    DhcpSearchResultStaticIPStatic = "no"
	DhcpSearchResultStaticIPStaticYes   DhcpSearchResultStaticIPStatic = "yes"
)

// Defines values for FilterCheckHostResponseReason.
const (
	FilterCheckHostResponseReasonFilteredBlackList      FilterCheckHostResponseReason = "FilteredBlackList"
	FilterCheckHostResponseReasonFilteredBlockedService FilterCheckHostResponseReason = "FilteredBlockedService"
	FilterCheckHostResponseReasonFilteredInvalid        FilterCheckHostResponseReason = "FilteredInvalid"
	FilterCheckHostResponseReasonFilteredParental       FilterCheckHostResponseReason = "FilteredParental"
	FilterCheckHostResponseReasonFilteredSafeBrowsing   FilterCheckHostResponseReason = "FilteredSafeBrowsing"
	FilterCheckHostResponseReasonFilteredSafeSearch     FilterCheckHostResponseReason = "FilteredSafeSearch"
	FilterCheckHostResponseReasonNotFilteredError       FilterCheckHostResponseReason = "NotFilteredError"
	FilterCheckHostResponseReasonNotFilteredNotFound    FilterCheckHostResponseReason = "NotFilteredNotFound"
	FilterCheckHostResponseReasonNotFilteredWhiteList   FilterCheckHostResponseReason = "NotFilteredWhiteList"
	FilterCheckHostResponseReasonRewrite                FilterCheckHostResponseReason = "Rewrite"
	FilterCheckHostResponseReasonRewriteEtcHosts        FilterCheckHostResponseReason = "RewriteEtcHosts"
	FilterCheckHostResponseReasonRewriteRule            FilterCheckHostResponseReason = "RewriteRule"
)

// Defines values for ProfileInfoTheme.
const (
	Auto  ProfileInfoTheme = "auto"
	Dark  ProfileInfoTheme = "dark"
	Light ProfileInfoTheme = "light"
)

// Defines values for QueryLogConfigInterval.
const (
	QueryLogConfigIntervalN025 QueryLogConfigInterval = 0.25
	QueryLogConfigIntervalN1   QueryLogConfigInterval = 1
	QueryLogConfigIntervalN30  QueryLogConfigInterval = 30
	QueryLogConfigIntervalN7   QueryLogConfigInterval = 7
	QueryLogConfigIntervalN90  QueryLogConfigInterval = 90
)

// Defines values for QueryLogItemReason.
const (
	QueryLogItemReasonFilteredBlackList      QueryLogItemReason = "FilteredBlackList"
	QueryLogItemReasonFilteredBlockedService QueryLogItemReason = "FilteredBlockedService"
	QueryLogItemReasonFilteredInvalid        QueryLogItemReason = "FilteredInvalid"
	QueryLogItemReasonFilteredParental       QueryLogItemReason = "FilteredParental"
	QueryLogItemReasonFilteredSafeBrowsing   QueryLogItemReason = "FilteredSafeBrowsing"
	QueryLogItemReasonFilteredSafeSearch     QueryLogItemReason = "FilteredSafeSearch"
	QueryLogItemReasonNotFilteredError       QueryLogItemReason = "NotFilteredError"
	QueryLogItemReasonNotFilteredNotFound    QueryLogItemReason = "NotFilteredNotFound"
	QueryLogItemReasonNotFilteredWhiteList   QueryLogItemReason = "NotFilteredWhiteList"
	QueryLogItemReasonRewrite                QueryLogItemReason = "Rewrite"
	QueryLogItemReasonRewriteEtcHosts        QueryLogItemReason = "RewriteEtcHosts"
	QueryLogItemReasonRewriteRule            QueryLogItemReason = "RewriteRule"
)

// Defines values for StatsTimeUnits.
const (
	Days  StatsTimeUnits = "days"
	Hours StatsTimeUnits = "hours"
)

// Defines values for StatsConfigInterval.
const (
	StatsConfigIntervalN0  StatsConfigInterval = 0
	StatsConfigIntervalN1  StatsConfigInterval = 1
	StatsConfigIntervalN30 StatsConfigInterval = 30
	StatsConfigIntervalN7  StatsConfigInterval = 7
	StatsConfigIntervalN90 StatsConfigInterval = 90
)

// Defines values for TlsConfigKeyType.
const (
	ECDSA TlsConfigKeyType = "ECDSA"
	RSA   TlsConfigKeyType = "RSA"
)

// Defines values for QueryLogParamsResponseStatus.
const (
	All                 QueryLogParamsResponseStatus = "all"
	Blocked             QueryLogParamsResponseStatus = "blocked"
	BlockedParental     QueryLogParamsResponseStatus = "blocked_parental"
	BlockedSafebrowsing QueryLogParamsResponseStatus = "blocked_safebrowsing"
	Filtered            QueryLogParamsResponseStatus = "filtered"
	Processed           QueryLogParamsResponseStatus = "processed"
	Rewritten           QueryLogParamsResponseStatus = "rewritten"
	SafeSearch          QueryLogParamsResponseStatus = "safe_search"
	Whitelisted         QueryLogParamsResponseStatus = "whitelisted"
)

// AccessList Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessList struct {
	// AllowedClients The allowlist of clients: IP addresses, CIDRs, or ClientIDs.
	AllowedClients *[]string `json:"allowed_clients,omitempty"`

	// BlockedHosts The blocklist of hosts.
	BlockedHosts *[]string `json:"blocked_hosts,omitempty"`

	// DisallowedClients The blocklist of clients: IP addresses, CIDRs, or ClientIDs.
	DisallowedClients *[]string `json:"disallowed_clients,omitempty"`
}

// AccessListResponse Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessListResponse = AccessList

// AccessSetRequest Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessSetRequest = AccessList

// AddUrlRequest /add_url request data
type AddUrlRequest struct {
	Name *string `json:"name,omitempty"`

	// Url URL or an absolute path to the file containing filtering rules.
	Url       *string `json:"url,omitempty"`
	Whitelist *bool   `json:"whitelist,omitempty"`
}

// AddressInfo Port information
type AddressInfo struct {
	Ip   string `json:"ip"`
	Port uint16 `json:"port"`
}

// AddressesInfo AdGuard Home addresses configuration
type AddressesInfo struct {
	DnsPort uint16 `json:"dns_port"`

	// Interfaces Network interfaces dictionary, keys are interface names.
	Interfaces NetInterfaces `json:"interfaces"`
	Version    string        `json:"version"`
	WebPort    uint16        `json:"web_port"`
}

// BlockedService defines model for BlockedService.
type BlockedService struct {
	// IconSvg The SVG icon as a Base64-encoded string to make it easier to embed it into a data URL.
	IconSvg string `json:"icon_svg"`

	// Id The ID of this service.
	Id string `json:"id"`

	// Name The human-readable name of this service.
	Name string `json:"name"`

	// Rules The array of the filtering rules.
	Rules []string `json:"rules"`
}

// BlockedServicesAll defines model for BlockedServicesAll.
type BlockedServicesAll struct {
	BlockedServices []BlockedService `json:"blocked_services"`
}

// BlockedServicesArray defines model for BlockedServicesArray.
type BlockedServicesArray = []string

// BlockedServicesSchedule defines model for BlockedServicesSchedule.
type BlockedServicesSchedule struct {
	// Ids The names of the blocked services.
	Ids *[]string `json:"ids,omitempty"`

	// Schedule Sets periods of inactivity for filtering blocked services.  The schedule contains 7 days (Sunday to Saturday) and a time zone.
	Schedule *Schedule `json:"schedule,omitempty"`
}

// CheckConfigRequest Configuration to be checked
type CheckConfigRequest struct {
	Dns         *CheckConfigRequestInfo `json:"dns,omitempty"`
	SetStaticIp *bool                   `json:"set_static_ip,omitempty"`
	Web         *CheckConfigRequestInfo `json:"web,omitempty"`
}

// CheckConfigRequestInfo defines model for CheckConfigRequestInfo.
type CheckConfigRequestInfo struct {
	Autofix *bool   `json:"autofix,omitempty"`
	Ip      *string `json:"ip,omitempty"`
	Port    *uint16 `json:"port,omitempty"`
}

// CheckConfigResponse defines model for CheckConfigResponse.
type CheckConfigResponse struct {
	Dns      CheckConfigResponseInfo `json:"dns"`
	StaticIp CheckConfigStaticIpInfo `json:"static_ip"`
	Web      CheckConfigResponseInfo `json:"web"`
}

// CheckConfigResponseInfo defines model for CheckConfigResponseInfo.
type CheckConfigResponseInfo struct {
	CanAutofix bool   `json:"can_autofix"`
	Status     string `json:"status"`
}

// CheckConfigStaticIpInfo defines model for CheckConfigStaticIpInfo.
type CheckConfigStaticIpInfo struct {
	// Error Error text. Set if static=error
	Error *string `json:"error,omitempty"`

	// Ip Current dynamic IP address. Set if static=no
	Ip *string `json:"ip,omitempty"`

	// Static Can be: yes, no, error
	Static *CheckConfigStaticIpInfoStatic `json:"static,omitempty"`
}

// CheckConfigStaticIpInfoStatic Can be: yes, no, error
type CheckConfigStaticIpInfoStatic string

// Client Client information.
type Client struct {
	BlockedServices *[]string `json:"blocked_services,omitempty"`

	// BlockedServicesSchedule Sets periods of inactivity for filtering blocked services.  The schedule contains 7 days (Sunday to Saturday) and a time zone.
	BlockedServicesSchedule *Schedule `json:"blocked_services_schedule,omitempty"`
	FilteringEnabled        *bool     `json:"filtering_enabled,omitempty"`

	// Ids IP, CIDR, MAC, or ClientID.
	Ids *[]string `json:"ids,omitempty"`

	// IgnoreQuerylog NOTE: If `ignore_querylog` is not set in HTTP API `GET /clients/add`
	// request then default value (false) will be used.
	//
	// If `ignore_querylog` is not set in HTTP API `GET /clients/update`
	// request then the existing value will not be changed.
	//
	// This behaviour can be changed in the future versions.
	IgnoreQuerylog *bool `json:"ignore_querylog,omitempty"`

	// IgnoreStatistics NOTE: If `ignore_statistics` is not set in HTTP API `GET
	// /clients/add` request then default value (false) will be used.
	//
	// If `ignore_statistics` is not set in HTTP API `GET /clients/update`
	// request then the existing value will not be changed.
	//
	// This behaviour can be changed in the future versions.
	IgnoreStatistics *bool `json:"ignore_statistics,omitempty"`

	// Name Name
	Name            *string `json:"name,omitempty"`
	ParentalEnabled *bool   `json:"parental_enabled,omitempty"`

	// SafeSearch Safe search settings.
	SafeSearch          *SafeSearchConfig `json:"safe_search,omitempty"`
	SafebrowsingEnabled *bool             `json:"safebrowsing_enabled,omitempty"`
	// Deprecated:
	SafesearchEnabled *bool     `json:"safesearch_enabled,omitempty"`
	Tags              *[]string `json:"tags,omitempty"`
	Upstreams         *[]string `json:"upstreams,omitempty"`

	// UpstreamsCacheEnabled NOTE: If `upstreams_cache_enabled` is not set in HTTP API
	// `GET /clients/add` request then default value (false) will be used.
	//
	// If `upstreams_cache_enabled` is not set in HTTP API
	// `GET /clients/update` request then the existing value will not be
	// changed.
	//
	// This behaviour can be changed in the future versions.
	UpstreamsCacheEnabled *bool `json:"upstreams_cache_enabled,omitempty"`

	// UpstreamsCacheSize NOTE: If `upstreams_cache_enabled` is not set in HTTP API
	// `GET /clients/update` request then the existing value will not be
	// changed.
	//
	// This behaviour can be changed in the future versions.
	UpstreamsCacheSize       *int  `json:"upstreams_cache_size,omitempty"`
	UseGlobalBlockedServices *bool `json:"use_global_blocked_services,omitempty"`
	UseGlobalSettings        *bool `json:"use_global_settings,omitempty"`
}

// ClientAuto Auto-Client information
type ClientAuto struct {
	// Ip IP address
	Ip *string `json:"ip,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// Source The source of this information
	Source    *string    `json:"source,omitempty"`
	WhoisInfo *WhoisInfo `json:"whois_info,omitempty"`
}

// ClientDelete Client delete request
type ClientDelete struct {
	Name *string `json:"name,omitempty"`
}

// ClientFindSubEntry Client information.
type ClientFindSubEntry struct {
	BlockedServices *[]string `json:"blocked_services,omitempty"`

	// Disallowed Whether the client's IP is blocked or not.
	Disallowed *bool `json:"disallowed,omitempty"`

	// DisallowedRule The rule due to which the client is disallowed.  If disallowed is set to true, and this string is empty, then the client IP is disallowed by the "allowed IP list", that is it is not included in the allowed list.
	DisallowedRule   *string `json:"disallowed_rule,omitempty"`
	FilteringEnabled *bool   `json:"filtering_enabled,omitempty"`

	// Ids IP, CIDR, MAC, or ClientID.
	Ids              *[]string `json:"ids,omitempty"`
	IgnoreQuerylog   *bool     `json:"ignore_querylog,omitempty"`
	IgnoreStatistics *bool     `json:"ignore_statistics,omitempty"`

	// Name Name
	Name            *string `json:"name,omitempty"`
	ParentalEnabled *bool   `json:"parental_enabled,omitempty"`

	// SafeSearch Safe search settings.
	SafeSearch          *SafeSearchConfig `json:"safe_search,omitempty"`
	SafebrowsingEnabled *bool             `json:"safebrowsing_enabled,omitempty"`
	// Deprecated:
	SafesearchEnabled        *bool      `json:"safesearch_enabled,omitempty"`
	Upstreams                *[]string  `json:"upstreams,omitempty"`
	UseGlobalBlockedServices *bool      `json:"use_global_blocked_services,omitempty"`
	UseGlobalSettings        *bool      `json:"use_global_settings,omitempty"`
	WhoisInfo                *WhoisInfo `json:"whois_info,omitempty"`
}

// ClientUpdate Client update request
type ClientUpdate struct {
	// Data Client information.
	Data *Client `json:"data,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Clients defines model for Clients.
type Clients struct {
	// AutoClients Auto-Clients array
	AutoClients *ClientsAutoArray `json:"auto_clients,omitempty"`

	// Clients Clients array
	Clients       *ClientsArray `json:"clients,omitempty"`
	SupportedTags *[]string     `json:"supported_tags,omitempty"`
}

// ClientsArray Clients array
type ClientsArray = []Client

// ClientsAutoArray Auto-Clients array
type ClientsAutoArray = []ClientAuto

// ClientsFindEntry defines model for ClientsFindEntry.
type ClientsFindEntry map[string]ClientFindSubEntry

// ClientsFindResponse Client search results.
type ClientsFindResponse = []ClientsFindEntry

// DNSConfig DNS server configuration
type DNSConfig struct {
	// BlockedResponseTtl TTL for blocked responses.
	BlockedResponseTtl *int                   `json:"blocked_response_ttl,omitempty"`
	BlockingIpv4       *string                `json:"blocking_ipv4,omitempty"`
	BlockingIpv6       *string                `json:"blocking_ipv6,omitempty"`
	BlockingMode       *DNSConfigBlockingMode `json:"blocking_mode,omitempty"`

	// BootstrapDns Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
	BootstrapDns    *[]string `json:"bootstrap_dns,omitempty"`
	CacheOptimistic *bool     `json:"cache_optimistic,omitempty"`
	CacheSize       *int      `json:"cache_size,omitempty"`
	CacheTtlMax     *int      `json:"cache_ttl_max,omitempty"`
	CacheTtlMin     *int      `json:"cache_ttl_min,omitempty"`
	DisableIpv6     *bool     `json:"disable_ipv6,omitempty"`
	DnssecEnabled   *bool     `json:"dnssec_enabled,omitempty"`
	EdnsCsCustomIp  *string   `json:"edns_cs_custom_ip,omitempty"`
	EdnsCsEnabled   *bool     `json:"edns_cs_enabled,omitempty"`
	EdnsCsUseCustom *bool     `json:"edns_cs_use_custom,omitempty"`

	// FallbackDns List of fallback DNS servers used when upstream DNS servers are not responding.  Empty value will clear the list.
	FallbackDns *[]string `json:"fallback_dns,omitempty"`

	// LocalPtrUpstreams Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	LocalPtrUpstreams *[]string `json:"local_ptr_upstreams,omitempty"`

	// ProtectionDisabledUntil Protection is pause until this time.  Nullable.
	ProtectionDisabledUntil *string `json:"protection_disabled_until,omitempty"`
	ProtectionEnabled       *bool   `json:"protection_enabled,omitempty"`
	Ratelimit               *int    `json:"ratelimit,omitempty"`

	// RatelimitSubnetSubnetLenIpv4 Length of the subnet mask for IPv4 addresses.
	RatelimitSubnetSubnetLenIpv4 *int `json:"ratelimit_subnet_subnet_len_ipv4,omitempty"`

	// RatelimitSubnetSubnetLenIpv6 Length of the subnet mask for IPv6 addresses.
	RatelimitSubnetSubnetLenIpv6 *int `json:"ratelimit_subnet_subnet_len_ipv6,omitempty"`

	// RatelimitWhitelist List of IP addresses excluded from rate limiting.
	RatelimitWhitelist *[]string `json:"ratelimit_whitelist,omitempty"`
	ResolveClients     *bool     `json:"resolve_clients,omitempty"`

	// UpstreamDns Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	UpstreamDns     *[]string `json:"upstream_dns,omitempty"`
	UpstreamDnsFile *string   `json:"upstream_dns_file,omitempty"`

	// UpstreamMode Upstream modes enumeration.
	UpstreamMode           *DNSConfigUpstreamMode `json:"upstream_mode,omitempty"`
	UsePrivatePtrResolvers *bool                  `json:"use_private_ptr_resolvers,omitempty"`
}

// DNSConfigBlockingMode defines model for DNSConfig.BlockingMode.
type DNSConfigBlockingMode string

// DNSConfigUpstreamMode Upstream modes enumeration.
type DNSConfigUpstreamMode string

// DayRange The single interval within a day.  It begins at the `start` and ends before the `end`.
type DayRange struct {
	// End The number of milliseconds elapsed from the start of a day.  It is expected to be rounded to minutes.  The maximum value is `86400000` (24 hours).
	End *float32 `json:"end,omitempty"`

	// Start The number of milliseconds elapsed from the start of a day.  It must be less than `end` and is expected to be rounded to minutes. So the maximum value is `86340000` (23 hours and 59 minutes).
	Start *float32 `json:"start,omitempty"`
}

// DhcpConfig defines model for DhcpConfig.
type DhcpConfig struct {
	Enabled       *bool         `json:"enabled,omitempty"`
	InterfaceName *string       `json:"interface_name,omitempty"`
	V4            *DhcpConfigV4 `json:"v4,omitempty"`
	V6            *DhcpConfigV6 `json:"v6,omitempty"`
}

// DhcpConfigV4 defines model for DhcpConfigV4.
type DhcpConfigV4 struct {
	GatewayIp     *string `json:"gateway_ip,omitempty"`
	LeaseDuration *int    `json:"lease_duration,omitempty"`
	RangeEnd      *string `json:"range_end,omitempty"`
	RangeStart    *string `json:"range_start,omitempty"`
	SubnetMask    *string `json:"subnet_mask,omitempty"`
}

// DhcpConfigV6 defines model for DhcpConfigV6.
type DhcpConfigV6 struct {
	LeaseDuration *int    `json:"lease_duration,omitempty"`
	RangeStart    *string `json:"range_start,omitempty"`
}

// DhcpFindActiveReq Request for checking for other DHCP servers in the network.
type DhcpFindActiveReq struct {
	// Interface The name of the network interface
	Interface *string `json:"interface,omitempty"`
}

// DhcpLease DHCP lease information
type DhcpLease struct {
	Expires  string `json:"expires"`
	Hostname string `json:"hostname"`
	Ip       string `json:"ip"`
	Mac      string `json:"mac"`
}

// DhcpSearchResult Information about a DHCP server discovered in the current network.
type DhcpSearchResult struct {
	V4 *DhcpSearchV4 `json:"v4,omitempty"`
	V6 *DhcpSearchV6 `json:"v6,omitempty"`
}

// DhcpSearchResultOtherServer defines model for DhcpSearchResultOtherServer.
type DhcpSearchResultOtherServer struct {
	// Error Set if found=error
	Error *string `json:"error,omitempty"`

	// Found The result of searching the other DHCP server.
	Found *DhcpSearchResultOtherServerFound `json:"found,omitempty"`
}

// DhcpSearchResultOtherServerFound The result of searching the other DHCP server.
type DhcpSearchResultOtherServerFound string

// DhcpSearchResultStaticIP defines model for DhcpSearchResultStaticIP.
type DhcpSearchResultStaticIP struct {
	// Ip Set if static=no
	Ip *string `json:"ip,omitempty"`

	// Static The result of determining static IP address.
	Static *DhcpSearchResultStaticIPStatic `json:"static,omitempty"`
}

// DhcpSearchResultStaticIPStatic The result of determining static IP address.
type DhcpSearchResultStaticIPStatic string

// DhcpSearchV4 defines model for DhcpSearchV4.
type DhcpSearchV4 struct {
	OtherServer *DhcpSearchResultOtherServer `json:"other_server,omitempty"`
	StaticIp    *DhcpSearchResultStaticIP    `json:"static_ip,omitempty"`
}

// DhcpSearchV6 defines model for DhcpSearchV6.
type DhcpSearchV6 struct {
	OtherServer *DhcpSearchResultOtherServer `json:"other_server,omitempty"`
}

// DhcpStaticLease DHCP static lease information
type DhcpStaticLease struct {
	Hostname string `json:"hostname"`
	Ip       string `json:"ip"`
	Mac      string `json:"mac"`
}

// DhcpStatus Built-in DHCP server configuration and status
type DhcpStatus struct {
	Enabled       *bool              `json:"enabled,omitempty"`
	InterfaceName *string            `json:"interface_name,omitempty"`
	Leases        []DhcpLease        `json:"leases"`
	StaticLeases  *[]DhcpStaticLease `json:"static_leases,omitempty"`
	V4            *DhcpConfigV4      `json:"v4,omitempty"`
	V6            *DhcpConfigV6      `json:"v6,omitempty"`
}

// DnsAnswer DNS answer section
type DnsAnswer struct {
	Ttl   *uint32 `json:"ttl,omitempty"`
	Type  *string `json:"type,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DnsQuestion DNS question section
type DnsQuestion struct {
	Class       *string `json:"class,omitempty"`
	Name        *string `json:"name,omitempty"`
	Type        *string `json:"type,omitempty"`
	UnicodeName *string `json:"unicode_name,omitempty"`
}

// Error A generic JSON error response.
type Error struct {
	// Message The error message, an opaque string.
	Message *string `json:"message,omitempty"`
}

// Filter Filter subscription info
type Filter struct {
	Enabled     bool       `json:"enabled"`
	Id          int64      `json:"id"`
	LastUpdated *time.Time `json:"last_updated,omitempty"`
	Name        string     `json:"name"`
	RulesCount  uint32     `json:"rules_count"`
	Url         string     `json:"url"`
}

// FilterCheckHostResponse Check Host Result
type FilterCheckHostResponse struct {
	// Cname Set if reason=Rewrite
	Cname *string `json:"cname,omitempty"`

	// FilterId In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	// Deprecated: use `rules[*].filter_list_id` instead.
	// Deprecated:
	FilterId *int `json:"filter_id,omitempty"`

	// IpAddrs Set if reason=Rewrite
	IpAddrs *[]string `json:"ip_addrs,omitempty"`

	// Reason Request filtering status.
	Reason *FilterCheckHostResponseReason `json:"reason,omitempty"`

	// Rule Filtering rule applied to the request (if any).
	// Deprecated: use `rules[*].text` instead.
	// Deprecated:
	Rule *string `json:"rule,omitempty"`

	// Rules Applied rules.
	Rules *[]ResultRule `json:"rules,omitempty"`

	// ServiceName Set if reason=FilteredBlockedService
	ServiceName *string `json:"service_name,omitempty"`
}

// FilterCheckHostResponseReason Request filtering status.
type FilterCheckHostResponseReason string

// FilterConfig Filtering settings
type FilterConfig struct {
	Enabled  *bool `json:"enabled,omitempty"`
	Interval *int  `json:"interval,omitempty"`
}

// FilterRefreshRequest Refresh Filters request data
type FilterRefreshRequest struct {
	Whitelist *bool `json:"whitelist,omitempty"`
}

// FilterRefreshResponse /filtering/refresh response data
type FilterRefreshResponse struct {
	Updated *int `json:"updated,omitempty"`
}

// FilterSetUrl Filtering URL settings
type FilterSetUrl struct {
	// Data Filter update data
	Data      *FilterSetUrlData `json:"data,omitempty"`
	Url       *string           `json:"url,omitempty"`
	Whitelist *bool             `json:"whitelist,omitempty"`
}

// FilterSetUrlData Filter update data
type FilterSetUrlData struct {
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
	Url     string `json:"url"`
}

// FilterStatus Filtering settings
type FilterStatus struct {
	Enabled          *bool     `json:"enabled,omitempty"`
	Filters          *[]Filter `json:"filters,omitempty"`
	Interval         *int      `json:"interval,omitempty"`
	UserRules        *[]string `json:"user_rules,omitempty"`
	WhitelistFilters *[]Filter `json:"whitelist_filters,omitempty"`
}

// GetQueryLogConfigResponse Query log configuration
type GetQueryLogConfigResponse struct {
	// AnonymizeClientIp Anonymize clients' IP addresses
	AnonymizeClientIp bool `json:"anonymize_client_ip"`

	// Enabled Is query log enabled
	Enabled bool `json:"enabled"`

	// Ignored List of host names, which should not be written to log
	Ignored []string `json:"ignored"`

	// Interval Time period for query log rotation in milliseconds.
	Interval float32 `json:"interval"`
}

// GetStatsConfigResponse Statistics configuration
type GetStatsConfigResponse struct {
	// Enabled Are statistics enabled
	Enabled bool `json:"enabled"`

	// Ignored List of host names, which should not be counted
	Ignored []string `json:"ignored"`

	// Interval Statistics rotation interval in milliseconds
	Interval float32 `json:"interval"`
}

// GetVersionRequest /version.json request data
type GetVersionRequest struct {
	// RecheckNow If false, server will check for a new version data only once in several hours.
	RecheckNow *bool `json:"recheck_now,omitempty"`
}

// InitialConfiguration AdGuard Home initial configuration for the first-install wizard.
type InitialConfiguration struct {
	// Dns Port information
	Dns AddressInfo `json:"dns"`

	// Password Basic auth password
	Password string `json:"password"`

	// Username Basic auth username
	Username string `json:"username"`

	// Web Port information
	Web AddressInfo `json:"web"`
}

// LanguageSettings Language settings object.
type LanguageSettings struct {
	// Language The current language or the language to set.
	Language string `json:"language"`
}

// Login Login request data
type Login struct {
	// Name User name
	Name *string `json:"name,omitempty"`

	// Password Password
	Password *string `json:"password,omitempty"`
}

// NetInterface Network interface info
type NetInterface struct {
	// Flags Flags could be any combination of the following values, divided by the "|" character: "up", "broadcast", "loopback", "pointtopoint" and "multicast".
	Flags           string    `json:"flags"`
	HardwareAddress string    `json:"hardware_address"`
	IpAddresses     *[]string `json:"ip_addresses,omitempty"`
	Mtu             int       `json:"mtu"`
	Name            string    `json:"name"`
}

// NetInterfaces Network interfaces dictionary, keys are interface names.
type NetInterfaces map[string]NetInterface

// ProfileInfo Information about the current user
type ProfileInfo struct {
	Language string `json:"language"`
	Name     string `json:"name"`

	// Theme Interface theme
	Theme ProfileInfoTheme `json:"theme"`
}

// ProfileInfoTheme Interface theme
type ProfileInfoTheme string

// PutQueryLogConfigUpdateRequest Query log configuration
type PutQueryLogConfigUpdateRequest = GetQueryLogConfigResponse

// PutStatsConfigUpdateRequest Statistics configuration
type PutStatsConfigUpdateRequest = GetStatsConfigResponse

// QueryLog Query log
type QueryLog struct {
	Data   *[]QueryLogItem `json:"data,omitempty"`
	Oldest *string         `json:"oldest,omitempty"`
}

// QueryLogConfig Query log configuration
type QueryLogConfig struct {
	// AnonymizeClientIp Anonymize clients' IP addresses
	AnonymizeClientIp *bool `json:"anonymize_client_ip,omitempty"`

	// Enabled Is query log enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Interval Time period for query log rotation.
	Interval *QueryLogConfigInterval `json:"interval,omitempty"`
}

// QueryLogConfigInterval Time period for query log rotation.
type QueryLogConfigInterval float32

// QueryLogItem Query log item
type QueryLogItem struct {
	Answer *[]DnsAnswer `json:"answer,omitempty"`

	// AnswerDnssec If true, the response had the Authenticated Data (AD) flag set.
	AnswerDnssec *bool `json:"answer_dnssec,omitempty"`

	// Cached Defines if the response has been served from cache.
	Cached *bool `json:"cached,omitempty"`

	// Client The client's IP address.
	Client *string `json:"client,omitempty"`

	// ClientId The ClientID, if provided in DoH, DoQ, or DoT.
	ClientId *string `json:"client_id,omitempty"`

	// ClientInfo Client information for a query log item.
	ClientInfo  *QueryLogItemClient `json:"client_info,omitempty"`
	ClientProto *interface{}        `json:"client_proto,omitempty"`

	// Ecs The IP network defined by an EDNS Client-Subnet option in the request message if any.
	Ecs       *string `json:"ecs,omitempty"`
	ElapsedMs *string `json:"elapsedMs,omitempty"`

	// FilterId In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	// Deprecated: use `rules[*].filter_list_id` instead.
	// Deprecated:
	FilterId *int `json:"filterId,omitempty"`

	// OriginalAnswer Answer from upstream server (optional)
	OriginalAnswer *[]DnsAnswer `json:"original_answer,omitempty"`

	// Question DNS question section
	Question *DnsQuestion `json:"question,omitempty"`

	// Reason Request filtering status.
	Reason *QueryLogItemReason `json:"reason,omitempty"`

	// Rule Filtering rule applied to the request (if any).
	// Deprecated: use `rules[*].text` instead.
	// Deprecated:
	Rule *string `json:"rule,omitempty"`

	// Rules Applied rules.
	Rules *[]ResultRule `json:"rules,omitempty"`

	// ServiceName Set if reason=FilteredBlockedService
	ServiceName *string `json:"service_name,omitempty"`

	// Status DNS response status
	Status *string `json:"status,omitempty"`

	// Time DNS request processing start time
	Time *string `json:"time,omitempty"`

	// Upstream Upstream URL starting with tcp://, tls://, https://, or with an IP address.
	Upstream *string `json:"upstream,omitempty"`
}

// QueryLogItemReason Request filtering status.
type QueryLogItemReason string

// QueryLogItemClient Client information for a query log item.
type QueryLogItemClient struct {
	// Disallowed Whether the client's IP is blocked or not.
	Disallowed bool `json:"disallowed"`

	// DisallowedRule The rule due to which the client is allowed or blocked.
	DisallowedRule string `json:"disallowed_rule"`

	// Name Persistent client's name or runtime client's hostname.  May be empty.
	Name string `json:"name"`

	// Whois Client WHOIS information, if any.
	Whois QueryLogItemClientWhois `json:"whois"`
}

// QueryLogItemClientWhois Client WHOIS information, if any.
type QueryLogItemClientWhois struct {
	// City City, if any.
	City *string `json:"city,omitempty"`

	// Country Country, if any.
	Country *string `json:"country,omitempty"`

	// Orgname Organization name, if any.
	Orgname *string `json:"orgname,omitempty"`
}

// RemoveUrlRequest /remove_url request data
type RemoveUrlRequest struct {
	// Url Previously added URL containing filtering rules
	Url       *string `json:"url,omitempty"`
	Whitelist *bool   `json:"whitelist,omitempty"`
}

// ResultRule Applied rule.
type ResultRule struct {
	// FilterListId In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	FilterListId *int64 `json:"filter_list_id,omitempty"`

	// Text The text of the filtering rule applied to the request (if any).
	Text *string `json:"text,omitempty"`
}

// RewriteEntry Rewrite rule
type RewriteEntry struct {
	// Answer value of A, AAAA or CNAME DNS record
	Answer *string `json:"answer,omitempty"`

	// Domain Domain name
	Domain *string `json:"domain,omitempty"`
}

// RewriteList Rewrite rules array
type RewriteList = []RewriteEntry

// RewriteUpdate Rewrite rule update object
type RewriteUpdate struct {
	// Target Rewrite rule
	Target *RewriteEntry `json:"target,omitempty"`

	// Update Rewrite rule
	Update *RewriteEntry `json:"update,omitempty"`
}

// SafeSearchConfig Safe search settings.
type SafeSearchConfig struct {
	Bing       *bool `json:"bing,omitempty"`
	Duckduckgo *bool `json:"duckduckgo,omitempty"`
	Ecosia     *bool `json:"ecosia,omitempty"`
	Enabled    *bool `json:"enabled,omitempty"`
	Google     *bool `json:"google,omitempty"`
	Pixabay    *bool `json:"pixabay,omitempty"`
	Yandex     *bool `json:"yandex,omitempty"`
	Youtube    *bool `json:"youtube,omitempty"`
}

// Schedule Sets periods of inactivity for filtering blocked services.  The schedule contains 7 days (Sunday to Saturday) and a time zone.
type Schedule struct {
	// Fri The single interval within a day.  It begins at the `start` and ends before the `end`.
	Fri *DayRange `json:"fri,omitempty"`

	// Mon The single interval within a day.  It begins at the `start` and ends before the `end`.
	Mon *DayRange `json:"mon,omitempty"`

	// Sat The single interval within a day.  It begins at the `start` and ends before the `end`.
	Sat *DayRange `json:"sat,omitempty"`

	// Sun The single interval within a day.  It begins at the `start` and ends before the `end`.
	Sun *DayRange `json:"sun,omitempty"`

	// Thu The single interval within a day.  It begins at the `start` and ends before the `end`.
	Thu *DayRange `json:"thu,omitempty"`

	// TimeZone Time zone name according to IANA time zone database.  For example `Europe/Brussels`.  `Local` represents the system's local time zone.
	TimeZone *string `json:"time_zone,omitempty"`

	// Tue The single interval within a day.  It begins at the `start` and ends before the `end`.
	Tue *DayRange `json:"tue,omitempty"`

	// Wed The single interval within a day.  It begins at the `start` and ends before the `end`.
	Wed *DayRange `json:"wed,omitempty"`
}

// ServerStatus AdGuard Home server status and configuration
type ServerStatus struct {
	DhcpAvailable              *bool    `json:"dhcp_available,omitempty"`
	DnsAddresses               []string `json:"dns_addresses"`
	DnsPort                    uint16   `json:"dns_port"`
	HttpPort                   uint16   `json:"http_port"`
	Language                   string   `json:"language"`
	ProtectionDisabledDuration *int64   `json:"protection_disabled_duration,omitempty"`
	ProtectionEnabled          bool     `json:"protection_enabled"`
	Running                    bool     `json:"running"`
	Version                    string   `json:"version"`
}

// SetProtectionRequest Protection state configuration
type SetProtectionRequest struct {
	// Duration Duration of a pause, in milliseconds.  Enabled should be false.
	Duration *uint64 `json:"duration,omitempty"`
	Enabled  bool    `json:"enabled"`
}

// SetRulesRequest Custom filtering rules setting request.
type SetRulesRequest struct {
	Rules *[]string `json:"rules,omitempty"`
}

// Stats Server statistics data
type Stats struct {
	// AvgProcessingTime Average time in seconds on processing a DNS request
	AvgProcessingTime *float32 `json:"avg_processing_time,omitempty"`
	BlockedFiltering  *[]int   `json:"blocked_filtering,omitempty"`
	DnsQueries        *[]int   `json:"dns_queries,omitempty"`

	// NumBlockedFiltering Number of requests blocked by filtering rules
	NumBlockedFiltering *int `json:"num_blocked_filtering,omitempty"`

	// NumDnsQueries Total number of DNS queries
	NumDnsQueries *int `json:"num_dns_queries,omitempty"`

	// NumReplacedParental Number of blocked adult websites
	NumReplacedParental *int `json:"num_replaced_parental,omitempty"`

	// NumReplacedSafebrowsing Number of requests blocked by safebrowsing module
	NumReplacedSafebrowsing *int `json:"num_replaced_safebrowsing,omitempty"`

	// NumReplacedSafesearch Number of requests blocked by safesearch module
	NumReplacedSafesearch *int   `json:"num_replaced_safesearch,omitempty"`
	ReplacedParental      *[]int `json:"replaced_parental,omitempty"`
	ReplacedSafebrowsing  *[]int `json:"replaced_safebrowsing,omitempty"`

	// TimeUnits Time units
	TimeUnits         *StatsTimeUnits  `json:"time_units,omitempty"`
	TopBlockedDomains *[]TopArrayEntry `json:"top_blocked_domains,omitempty"`
	TopClients        *[]TopArrayEntry `json:"top_clients,omitempty"`
	TopQueriedDomains *[]TopArrayEntry `json:"top_queried_domains,omitempty"`

	// TopUpstreamsAvgTime Average processing time in seconds of requests from each upstream.
	TopUpstreamsAvgTime *[]TopArrayEntry `json:"top_upstreams_avg_time,omitempty"`

	// TopUpstreamsResponses Total number of responses from each upstream.
	TopUpstreamsResponses *[]TopArrayEntry `json:"top_upstreams_responses,omitempty"`
}

// StatsTimeUnits Time units
type StatsTimeUnits string

// StatsConfig Statistics configuration
type StatsConfig struct {
	// Interval Time period to keep the data.  `0` means that the statistics is disabled.
	Interval *StatsConfigInterval `json:"interval,omitempty"`
}

// StatsConfigInterval Time period to keep the data.  `0` means that the statistics is disabled.
type StatsConfigInterval int

// TlsConfig TLS configuration settings and status
type TlsConfig struct {
	// CertificateChain Base64 string with PEM-encoded certificates chain
	CertificateChain *string `json:"certificate_chain,omitempty"`

	// CertificatePath Path to certificate file
	CertificatePath *string `json:"certificate_path,omitempty"`

	// DnsNames The value of SubjectAltNames field of the first certificate in the chain.
	DnsNames *[]string `json:"dns_names,omitempty"`

	// Enabled enabled is the encryption (DoT/DoH/HTTPS) status
	Enabled *bool `json:"enabled,omitempty"`

	// ForceHttps if true, forces HTTP->HTTPS redirect
	ForceHttps *bool `json:"force_https,omitempty"`

	// Issuer The issuer of the first certificate in the chain.
	Issuer *string `json:"issuer,omitempty"`

	// KeyType Key type.
	KeyType *TlsConfigKeyType `json:"key_type,omitempty"`

	// NotAfter The NotAfter field of the first certificate in the chain.
	NotAfter *string `json:"not_after,omitempty"`

	// NotBefore The NotBefore field of the first certificate in the chain.
	NotBefore *string `json:"not_before,omitempty"`

	// PortDnsOverQuic DNS-over-QUIC port. If 0, DoQ will be disabled.
	PortDnsOverQuic *uint16 `json:"port_dns_over_quic,omitempty"`

	// PortDnsOverTls DNS-over-TLS port. If 0, DoT will be disabled.
	PortDnsOverTls *uint16 `json:"port_dns_over_tls,omitempty"`

	// PortHttps HTTPS port. If 0, HTTPS will be disabled.
	PortHttps *uint16 `json:"port_https,omitempty"`

	// PrivateKey Base64 string with PEM-encoded private key
	PrivateKey *string `json:"private_key,omitempty"`

	// PrivateKeyPath Path to private key file
	PrivateKeyPath *string `json:"private_key_path,omitempty"`

	// PrivateKeySaved Set to true if the user has previously saved a private key as a string.  This is used so that the server and the client don't have to send the private key between each other every time, which might lead to security issues.
	PrivateKeySaved *bool `json:"private_key_saved,omitempty"`

	// ServePlainDns Set to true if plain DNS is allowed for incoming requests.
	ServePlainDns *bool `json:"serve_plain_dns,omitempty"`

	// ServerName server_name is the hostname of your HTTPS/TLS server
	ServerName *string `json:"server_name,omitempty"`

	// Subject The subject of the first certificate in the chain.
	Subject *string `json:"subject,omitempty"`

	// ValidCert Set to true if the specified certificates chain is a valid chain of X509 certificates.
	ValidCert *bool `json:"valid_cert,omitempty"`

	// ValidChain Set to true if the specified certificates chain is verified and issued by a known CA.
	ValidChain *bool `json:"valid_chain,omitempty"`

	// ValidKey Set to true if the key is a valid private key.
	ValidKey *bool `json:"valid_key,omitempty"`

	// ValidPair Set to true if both certificate and private key are correct.
	ValidPair *bool `json:"valid_pair,omitempty"`

	// WarningValidation A validation warning message with the issue description.
	WarningValidation *string `json:"warning_validation,omitempty"`
}

// TlsConfigKeyType Key type.
type TlsConfigKeyType string

// TopArrayEntry Represent the number of hits or time duration per key (url, domain, or client IP).
type TopArrayEntry struct {
	DomainOrIp           *float32           `json:"domain_or_ip,omitempty"`
	AdditionalProperties map[string]float32 `json:"-"`
}

// UpstreamsConfig Upstream configuration to be tested
type UpstreamsConfig struct {
	// BootstrapDns Bootstrap DNS servers, port is optional after colon.
	BootstrapDns []string `json:"bootstrap_dns"`

	// FallbackDns Fallback DNS servers, port is optional after colon.
	FallbackDns *[]string `json:"fallback_dns,omitempty"`

	// PrivateUpstream Local PTR resolvers, port is optional after colon.
	PrivateUpstream *[]string `json:"private_upstream,omitempty"`

	// UpstreamDns Upstream DNS servers, port is optional after colon.
	UpstreamDns []string `json:"upstream_dns"`
}

// UpstreamsConfigResponse Upstreams configuration response
type UpstreamsConfigResponse map[string]string

// VersionInfo Information about the latest available version of AdGuard Home.
type VersionInfo struct {
	Announcement    *string `json:"announcement,omitempty"`
	AnnouncementUrl *string `json:"announcement_url,omitempty"`
	CanAutoupdate   *bool   `json:"can_autoupdate,omitempty"`

	// Disabled If true then other fields doesn't appear.
	Disabled   bool    `json:"disabled"`
	NewVersion *string `json:"new_version,omitempty"`
}

// WhoisInfo defines model for WhoisInfo.
type WhoisInfo map[string]string

// DhcpStaticLeaseBody DHCP static lease information
type DhcpStaticLeaseBody = DhcpStaticLease

// RewriteEntryBody Rewrite rule
type RewriteEntryBody = RewriteEntry

// RewriteUpdateBody Rewrite rule update object
type RewriteUpdateBody = RewriteUpdate

// TlsConfigBody TLS configuration settings and status
type TlsConfigBody = TlsConfig

// MobileConfigDoHParams defines parameters for MobileConfigDoH.
type MobileConfigDoHParams struct {
	// Host Host for which the config is generated.  If no host is provided, `tls.server_name` from the configuration file is used.  If `tls.server_name` is not set, the API returns an error with a 500 status.
	Host string `form:"host" json:"host"`

	// ClientId ClientID.
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`
}

// MobileConfigDoTParams defines parameters for MobileConfigDoT.
type MobileConfigDoTParams struct {
	// Host Host for which the config is generated.  If no host is provided, `tls.server_name` from the configuration file is used.  If `tls.server_name` is not set, the API returns an error with a 500 status.
	Host string `form:"host" json:"host"`

	// ClientId ClientID.
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`
}

// ClientsFindParams defines parameters for ClientsFind.
type ClientsFindParams struct {
	// Ip0 Filter by IP address or ClientIDs.  Parameters with names `ip1`, `ip2`, and so on are also accepted and interpreted as "ip0 OR ip1 OR ip2".
	// TODO(a.garipov): Replace with a better query API.
	Ip0 *string `form:"ip0,omitempty" json:"ip0,omitempty"`
}

// FilteringCheckHostParams defines parameters for FilteringCheckHost.
type FilteringCheckHostParams struct {
	// Name Filter by host name
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// QueryLogParams defines parameters for QueryLog.
type QueryLogParams struct {
	// OlderThan Filter by older than
	OlderThan *string `form:"older_than,omitempty" json:"older_than,omitempty"`

	// Offset Specify the ranking number of the first item on the page.  Even though it is possible to use "offset" and "older_than", we recommend choosing one of them and sticking to it.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Limit the number of records to be returned
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Search Filter by domain name or client IP
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// ResponseStatus Filter by response status
	ResponseStatus *QueryLogParamsResponseStatus `form:"response_status,omitempty" json:"response_status,omitempty"`
}

// QueryLogParamsResponseStatus defines parameters for QueryLog.
type QueryLogParamsResponseStatus string

// AccessSetJSONRequestBody defines body for AccessSet for application/json ContentType.
type AccessSetJSONRequestBody = AccessSetRequest

// BlockedServicesSetJSONRequestBody defines body for BlockedServicesSet for application/json ContentType.
type BlockedServicesSetJSONRequestBody = BlockedServicesArray

// BlockedServicesScheduleUpdateJSONRequestBody defines body for BlockedServicesScheduleUpdate for application/json ContentType.
type BlockedServicesScheduleUpdateJSONRequestBody = BlockedServicesSchedule

// ClientsAddJSONRequestBody defines body for ClientsAdd for application/json ContentType.
type ClientsAddJSONRequestBody = Client

// ClientsDeleteJSONRequestBody defines body for ClientsDelete for application/json ContentType.
type ClientsDeleteJSONRequestBody = ClientDelete

// ClientsUpdateJSONRequestBody defines body for ClientsUpdate for application/json ContentType.
type ClientsUpdateJSONRequestBody = ClientUpdate

// DhcpAddStaticLeaseJSONRequestBody defines body for DhcpAddStaticLease for application/json ContentType.
type DhcpAddStaticLeaseJSONRequestBody = DhcpStaticLease

// CheckActiveDhcpJSONRequestBody defines body for CheckActiveDhcp for application/json ContentType.
type CheckActiveDhcpJSONRequestBody = DhcpFindActiveReq

// DhcpRemoveStaticLeaseJSONRequestBody defines body for DhcpRemoveStaticLease for application/json ContentType.
type DhcpRemoveStaticLeaseJSONRequestBody = DhcpStaticLease

// DhcpSetConfigJSONRequestBody defines body for DhcpSetConfig for application/json ContentType.
type DhcpSetConfigJSONRequestBody = DhcpConfig

// DhcpUpdateStaticLeaseJSONRequestBody defines body for DhcpUpdateStaticLease for application/json ContentType.
type DhcpUpdateStaticLeaseJSONRequestBody = DhcpStaticLease

// DnsConfigJSONRequestBody defines body for DnsConfig for application/json ContentType.
type DnsConfigJSONRequestBody = DNSConfig

// FilteringAddURLJSONRequestBody defines body for FilteringAddURL for application/json ContentType.
type FilteringAddURLJSONRequestBody = AddUrlRequest

// FilteringConfigJSONRequestBody defines body for FilteringConfig for application/json ContentType.
type FilteringConfigJSONRequestBody = FilterConfig

// FilteringRefreshJSONRequestBody defines body for FilteringRefresh for application/json ContentType.
type FilteringRefreshJSONRequestBody = FilterRefreshRequest

// FilteringRemoveURLJSONRequestBody defines body for FilteringRemoveURL for application/json ContentType.
type FilteringRemoveURLJSONRequestBody = RemoveUrlRequest

// FilteringSetRulesJSONRequestBody defines body for FilteringSetRules for application/json ContentType.
type FilteringSetRulesJSONRequestBody = SetRulesRequest

// FilteringSetURLJSONRequestBody defines body for FilteringSetURL for application/json ContentType.
type FilteringSetURLJSONRequestBody = FilterSetUrl

// ChangeLanguageJSONRequestBody defines body for ChangeLanguage for application/json ContentType.
type ChangeLanguageJSONRequestBody = LanguageSettings

// InstallCheckConfigJSONRequestBody defines body for InstallCheckConfig for application/json ContentType.
type InstallCheckConfigJSONRequestBody = CheckConfigRequest

// InstallConfigureJSONRequestBody defines body for InstallConfigure for application/json ContentType.
type InstallConfigureJSONRequestBody = InitialConfiguration

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = Login

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody = ProfileInfo

// SetProtectionJSONRequestBody defines body for SetProtection for application/json ContentType.
type SetProtectionJSONRequestBody = SetProtectionRequest

// PutQueryLogConfigJSONRequestBody defines body for PutQueryLogConfig for application/json ContentType.
type PutQueryLogConfigJSONRequestBody = PutQueryLogConfigUpdateRequest

// QueryLogConfigJSONRequestBody defines body for QueryLogConfig for application/json ContentType.
type QueryLogConfigJSONRequestBody = QueryLogConfig

// RewriteAddJSONRequestBody defines body for RewriteAdd for application/json ContentType.
type RewriteAddJSONRequestBody = RewriteEntry

// RewriteDeleteJSONRequestBody defines body for RewriteDelete for application/json ContentType.
type RewriteDeleteJSONRequestBody = RewriteEntry

// RewriteUpdateJSONRequestBody defines body for RewriteUpdate for application/json ContentType.
type RewriteUpdateJSONRequestBody = RewriteUpdate

// SafesearchSettingsJSONRequestBody defines body for SafesearchSettings for application/json ContentType.
type SafesearchSettingsJSONRequestBody = SafeSearchConfig

// PutStatsConfigJSONRequestBody defines body for PutStatsConfig for application/json ContentType.
type PutStatsConfigJSONRequestBody = PutStatsConfigUpdateRequest

// StatsConfigJSONRequestBody defines body for StatsConfig for application/json ContentType.
type StatsConfigJSONRequestBody = StatsConfig

// TestUpstreamDNSJSONRequestBody defines body for TestUpstreamDNS for application/json ContentType.
type TestUpstreamDNSJSONRequestBody = UpstreamsConfig

// TlsConfigureJSONRequestBody defines body for TlsConfigure for application/json ContentType.
type TlsConfigureJSONRequestBody = TlsConfig

// TlsValidateJSONRequestBody defines body for TlsValidate for application/json ContentType.
type TlsValidateJSONRequestBody = TlsConfig

// GetVersionJsonJSONRequestBody defines body for GetVersionJson for application/json ContentType.
type GetVersionJsonJSONRequestBody = GetVersionRequest

// Getter for additional properties for TopArrayEntry. Returns the specified
// element and whether it was found
func (a TopArrayEntry) Get(fieldName string) (value float32, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TopArrayEntry
func (a *TopArrayEntry) Set(fieldName string, value float32) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]float32)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TopArrayEntry to handle AdditionalProperties
func (a *TopArrayEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["domain_or_ip"]; found {
		err = json.Unmarshal(raw, &a.DomainOrIp)
		if err != nil {
			return fmt.Errorf("error reading 'domain_or_ip': %w", err)
		}
		delete(object, "domain_or_ip")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]float32)
		for fieldName, fieldBuf := range object {
			var fieldVal float32
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TopArrayEntry to handle AdditionalProperties
func (a TopArrayEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DomainOrIp != nil {
		object["domain_or_ip"], err = json.Marshal(a.DomainOrIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'domain_or_ip': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// AdguardHomeClient which conforms to the OpenAPI3 specification for this service.
type AdguardHomeClient struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*AdguardHomeClient) error

// Creates a new AdguardHomeClient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*AdguardHomeClient, error) {
	// create a client with sane default values
	client := AdguardHomeClient{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *AdguardHomeClient) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *AdguardHomeClient) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AccessList request
	AccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccessSetWithBody request with any body
	AccessSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AccessSet(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MobileConfigDoH request
	MobileConfigDoH(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MobileConfigDoT request
	MobileConfigDoT(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesAll request
	BlockedServicesAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesSchedule request
	BlockedServicesSchedule(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesList request
	BlockedServicesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesAvailableServices request
	BlockedServicesAvailableServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesSetWithBody request with any body
	BlockedServicesSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BlockedServicesSet(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockedServicesScheduleUpdateWithBody request with any body
	BlockedServicesScheduleUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BlockedServicesScheduleUpdate(ctx context.Context, body BlockedServicesScheduleUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheClear request
	CacheClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsStatus request
	ClientsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsAddWithBody request with any body
	ClientsAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClientsAdd(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsDeleteWithBody request with any body
	ClientsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClientsDelete(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsFind request
	ClientsFind(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClientsUpdateWithBody request with any body
	ClientsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClientsUpdate(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpAddStaticLeaseWithBody request with any body
	DhcpAddStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpAddStaticLease(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckActiveDhcpWithBody request with any body
	CheckActiveDhcpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckActiveDhcp(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpInterfaces request
	DhcpInterfaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpRemoveStaticLeaseWithBody request with any body
	DhcpRemoveStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpRemoveStaticLease(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpReset request
	DhcpReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpResetLeases request
	DhcpResetLeases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpSetConfigWithBody request with any body
	DhcpSetConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpSetConfig(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpStatus request
	DhcpStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DhcpUpdateStaticLeaseWithBody request with any body
	DhcpUpdateStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DhcpUpdateStaticLease(ctx context.Context, body DhcpUpdateStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsConfigWithBody request with any body
	DnsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DnsConfig(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DnsInfo request
	DnsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringAddURLWithBody request with any body
	FilteringAddURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringAddURL(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringCheckHost request
	FilteringCheckHost(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringConfigWithBody request with any body
	FilteringConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringConfig(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringRefreshWithBody request with any body
	FilteringRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringRefresh(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringRemoveURLWithBody request with any body
	FilteringRemoveURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringRemoveURL(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringSetRulesWithBody request with any body
	FilteringSetRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringSetRules(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringSetURLWithBody request with any body
	FilteringSetURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilteringSetURL(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilteringStatus request
	FilteringStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeLanguageWithBody request with any body
	ChangeLanguageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeLanguage(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentLanguage request
	CurrentLanguage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallCheckConfigWithBody request with any body
	InstallCheckConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallCheckConfig(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallConfigureWithBody request with any body
	InstallConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallConfigure(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallGetAddresses request
	InstallGetAddresses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParentalDisable request
	ParentalDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParentalEnable request
	ParentalEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ParentalStatus request
	ParentalStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfile request
	GetProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfileWithBody request with any body
	UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProtectionWithBody request with any body
	SetProtectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetProtection(ctx context.Context, body SetProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryLog request
	QueryLog(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQueryLogConfig request
	GetQueryLogConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutQueryLogConfigWithBody request with any body
	PutQueryLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutQueryLogConfig(ctx context.Context, body PutQueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QuerylogClear request
	QuerylogClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryLogConfigWithBody request with any body
	QueryLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryLogConfig(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryLogInfo request
	QueryLogInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteAddWithBody request with any body
	RewriteAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RewriteAdd(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteDeleteWithBody request with any body
	RewriteDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RewriteDelete(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteList request
	RewriteList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RewriteUpdateWithBody request with any body
	RewriteUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RewriteUpdate(ctx context.Context, body RewriteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafebrowsingDisable request
	SafebrowsingDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafebrowsingEnable request
	SafebrowsingEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafebrowsingStatus request
	SafebrowsingStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchDisable request
	SafesearchDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchEnable request
	SafesearchEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchSettingsWithBody request with any body
	SafesearchSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SafesearchSettings(ctx context.Context, body SafesearchSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SafesearchStatus request
	SafesearchStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stats request
	Stats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatsConfig request
	GetStatsConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutStatsConfigWithBody request with any body
	PutStatsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutStatsConfig(ctx context.Context, body PutStatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsConfigWithBody request with any body
	StatsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StatsConfig(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsInfo request
	StatsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsReset request
	StatsReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Status request
	Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestUpstreamDNSWithBody request with any body
	TestUpstreamDNSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestUpstreamDNS(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TlsConfigureWithBody request with any body
	TlsConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TlsConfigure(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TlsStatus request
	TlsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TlsValidateWithBody request with any body
	TlsValidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TlsValidate(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BeginUpdate request
	BeginUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersionJsonWithBody request with any body
	GetVersionJsonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetVersionJson(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *AdguardHomeClient) AccessList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccessListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) AccessSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccessSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) AccessSet(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccessSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) MobileConfigDoH(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMobileConfigDoHRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) MobileConfigDoT(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMobileConfigDoTRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesSchedule(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesScheduleRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesAvailableServices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesAvailableServicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesSetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesSetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesSet(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesSetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesScheduleUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesScheduleUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BlockedServicesScheduleUpdate(ctx context.Context, body BlockedServicesScheduleUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockedServicesScheduleUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CacheClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheClearRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsAdd(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsDelete(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsFind(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsFindRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ClientsUpdate(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClientsUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpAddStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpAddStaticLeaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpAddStaticLease(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpAddStaticLeaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CheckActiveDhcpWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckActiveDhcpRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CheckActiveDhcp(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckActiveDhcpRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpInterfaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpInterfacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpRemoveStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpRemoveStaticLeaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpRemoveStaticLease(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpRemoveStaticLeaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpResetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpResetLeases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpResetLeasesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpSetConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpSetConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpSetConfig(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpSetConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpUpdateStaticLeaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpUpdateStaticLeaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DhcpUpdateStaticLease(ctx context.Context, body DhcpUpdateStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDhcpUpdateStaticLeaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DnsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DnsConfig(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) DnsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDnsInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringAddURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringAddURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringAddURL(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringAddURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringCheckHost(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringCheckHostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringConfig(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRefreshWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRefreshRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRefresh(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRefreshRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRemoveURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRemoveURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringRemoveURL(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringRemoveURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetRulesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetRules(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetRulesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetURLWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetURLRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringSetURL(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringSetURLRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) FilteringStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilteringStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ChangeLanguageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeLanguageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ChangeLanguage(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeLanguageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) CurrentLanguage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentLanguageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallCheckConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallCheckConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallCheckConfig(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallCheckConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallConfigureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallConfigure(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallConfigureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) InstallGetAddresses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallGetAddressesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ParentalDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParentalDisableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ParentalEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParentalEnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) ParentalStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewParentalStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SetProtectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetProtectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SetProtection(ctx context.Context, body SetProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetProtectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLog(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetQueryLogConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQueryLogConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) PutQueryLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutQueryLogConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) PutQueryLogConfig(ctx context.Context, body PutQueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutQueryLogConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QuerylogClear(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerylogClearRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLogConfig(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) QueryLogInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryLogInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteAdd(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteDelete(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) RewriteUpdate(ctx context.Context, body RewriteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRewriteUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafebrowsingDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafebrowsingDisableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafebrowsingEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafebrowsingEnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafebrowsingStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafebrowsingStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchDisable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchDisableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchEnable(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchEnableRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchSettings(ctx context.Context, body SafesearchSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) SafesearchStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSafesearchStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Stats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetStatsConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) PutStatsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStatsConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) PutStatsConfig(ctx context.Context, body PutStatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStatsConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsConfig(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) StatsReset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsResetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TestUpstreamDNSWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUpstreamDNSRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TestUpstreamDNS(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestUpstreamDNSRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsConfigureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsConfigureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsConfigure(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsConfigureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsValidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsValidateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) TlsValidate(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTlsValidateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) BeginUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeginUpdateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetVersionJsonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionJsonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *AdguardHomeClient) GetVersionJson(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionJsonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAccessListRequest generates requests for AccessList
func NewAccessListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccessSetRequest calls the generic AccessSet builder with application/json body
func NewAccessSetRequest(server string, body AccessSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAccessSetRequestWithBody(server, "application/json", bodyReader)
}

// NewAccessSetRequestWithBody generates requests for AccessSet with any type of body
func NewAccessSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access/set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMobileConfigDoHRequest generates requests for MobileConfigDoH
func NewMobileConfigDoHRequest(server string, params *MobileConfigDoHParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apple/doh.mobileconfig")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, params.Host); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMobileConfigDoTRequest generates requests for MobileConfigDoT
func NewMobileConfigDoTRequest(server string, params *MobileConfigDoTParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apple/dot.mobileconfig")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, params.Host); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ClientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesAllRequest generates requests for BlockedServicesAll
func NewBlockedServicesAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesScheduleRequest generates requests for BlockedServicesSchedule
func NewBlockedServicesScheduleRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesListRequest generates requests for BlockedServicesList
func NewBlockedServicesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesAvailableServicesRequest generates requests for BlockedServicesAvailableServices
func NewBlockedServicesAvailableServicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockedServicesSetRequest calls the generic BlockedServicesSet builder with application/json body
func NewBlockedServicesSetRequest(server string, body BlockedServicesSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBlockedServicesSetRequestWithBody(server, "application/json", bodyReader)
}

// NewBlockedServicesSetRequestWithBody generates requests for BlockedServicesSet with any type of body
func NewBlockedServicesSetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBlockedServicesScheduleUpdateRequest calls the generic BlockedServicesScheduleUpdate builder with application/json body
func NewBlockedServicesScheduleUpdateRequest(server string, body BlockedServicesScheduleUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBlockedServicesScheduleUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewBlockedServicesScheduleUpdateRequestWithBody generates requests for BlockedServicesScheduleUpdate with any type of body
func NewBlockedServicesScheduleUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blocked_services/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheClearRequest generates requests for CacheClear
func NewCacheClearRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cache_clear")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClientsStatusRequest generates requests for ClientsStatus
func NewClientsStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClientsAddRequest calls the generic ClientsAdd builder with application/json body
func NewClientsAddRequest(server string, body ClientsAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClientsAddRequestWithBody(server, "application/json", bodyReader)
}

// NewClientsAddRequestWithBody generates requests for ClientsAdd with any type of body
func NewClientsAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClientsDeleteRequest calls the generic ClientsDelete builder with application/json body
func NewClientsDeleteRequest(server string, body ClientsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClientsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewClientsDeleteRequestWithBody generates requests for ClientsDelete with any type of body
func NewClientsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClientsFindRequest generates requests for ClientsFind
func NewClientsFindRequest(server string, params *ClientsFindParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ip0 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip0", runtime.ParamLocationQuery, *params.Ip0); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClientsUpdateRequest calls the generic ClientsUpdate builder with application/json body
func NewClientsUpdateRequest(server string, body ClientsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClientsUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewClientsUpdateRequestWithBody generates requests for ClientsUpdate with any type of body
func NewClientsUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clients/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpAddStaticLeaseRequest calls the generic DhcpAddStaticLease builder with application/json body
func NewDhcpAddStaticLeaseRequest(server string, body DhcpAddStaticLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpAddStaticLeaseRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpAddStaticLeaseRequestWithBody generates requests for DhcpAddStaticLease with any type of body
func NewDhcpAddStaticLeaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/add_static_lease")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckActiveDhcpRequest calls the generic CheckActiveDhcp builder with application/json body
func NewCheckActiveDhcpRequest(server string, body CheckActiveDhcpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckActiveDhcpRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckActiveDhcpRequestWithBody generates requests for CheckActiveDhcp with any type of body
func NewCheckActiveDhcpRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/find_active_dhcp")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpInterfacesRequest generates requests for DhcpInterfaces
func NewDhcpInterfacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpRemoveStaticLeaseRequest calls the generic DhcpRemoveStaticLease builder with application/json body
func NewDhcpRemoveStaticLeaseRequest(server string, body DhcpRemoveStaticLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpRemoveStaticLeaseRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpRemoveStaticLeaseRequestWithBody generates requests for DhcpRemoveStaticLease with any type of body
func NewDhcpRemoveStaticLeaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/remove_static_lease")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpResetRequest generates requests for DhcpReset
func NewDhcpResetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpResetLeasesRequest generates requests for DhcpResetLeases
func NewDhcpResetLeasesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/reset_leases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpSetConfigRequest calls the generic DhcpSetConfig builder with application/json body
func NewDhcpSetConfigRequest(server string, body DhcpSetConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpSetConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpSetConfigRequestWithBody generates requests for DhcpSetConfig with any type of body
func NewDhcpSetConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/set_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDhcpStatusRequest generates requests for DhcpStatus
func NewDhcpStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDhcpUpdateStaticLeaseRequest calls the generic DhcpUpdateStaticLease builder with application/json body
func NewDhcpUpdateStaticLeaseRequest(server string, body DhcpUpdateStaticLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDhcpUpdateStaticLeaseRequestWithBody(server, "application/json", bodyReader)
}

// NewDhcpUpdateStaticLeaseRequestWithBody generates requests for DhcpUpdateStaticLease with any type of body
func NewDhcpUpdateStaticLeaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dhcp/update_static_lease")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsConfigRequest calls the generic DnsConfig builder with application/json body
func NewDnsConfigRequest(server string, body DnsConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDnsConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewDnsConfigRequestWithBody generates requests for DnsConfig with any type of body
func NewDnsConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dns_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDnsInfoRequest generates requests for DnsInfo
func NewDnsInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dns_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFilteringAddURLRequest calls the generic FilteringAddURL builder with application/json body
func NewFilteringAddURLRequest(server string, body FilteringAddURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringAddURLRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringAddURLRequestWithBody generates requests for FilteringAddURL with any type of body
func NewFilteringAddURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/add_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringCheckHostRequest generates requests for FilteringCheckHost
func NewFilteringCheckHostRequest(server string, params *FilteringCheckHostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/check_host")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFilteringConfigRequest calls the generic FilteringConfig builder with application/json body
func NewFilteringConfigRequest(server string, body FilteringConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringConfigRequestWithBody generates requests for FilteringConfig with any type of body
func NewFilteringConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringRefreshRequest calls the generic FilteringRefresh builder with application/json body
func NewFilteringRefreshRequest(server string, body FilteringRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringRefreshRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringRefreshRequestWithBody generates requests for FilteringRefresh with any type of body
func NewFilteringRefreshRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringRemoveURLRequest calls the generic FilteringRemoveURL builder with application/json body
func NewFilteringRemoveURLRequest(server string, body FilteringRemoveURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringRemoveURLRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringRemoveURLRequestWithBody generates requests for FilteringRemoveURL with any type of body
func NewFilteringRemoveURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/remove_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringSetRulesRequest calls the generic FilteringSetRules builder with application/json body
func NewFilteringSetRulesRequest(server string, body FilteringSetRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringSetRulesRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringSetRulesRequestWithBody generates requests for FilteringSetRules with any type of body
func NewFilteringSetRulesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/set_rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringSetURLRequest calls the generic FilteringSetURL builder with application/json body
func NewFilteringSetURLRequest(server string, body FilteringSetURLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilteringSetURLRequestWithBody(server, "application/json", bodyReader)
}

// NewFilteringSetURLRequestWithBody generates requests for FilteringSetURL with any type of body
func NewFilteringSetURLRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/set_url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFilteringStatusRequest generates requests for FilteringStatus
func NewFilteringStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filtering/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeLanguageRequest calls the generic ChangeLanguage builder with application/json body
func NewChangeLanguageRequest(server string, body ChangeLanguageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeLanguageRequestWithBody(server, "application/json", bodyReader)
}

// NewChangeLanguageRequestWithBody generates requests for ChangeLanguage with any type of body
func NewChangeLanguageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/i18n/change_language")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCurrentLanguageRequest generates requests for CurrentLanguage
func NewCurrentLanguageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/i18n/current_language")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallCheckConfigRequest calls the generic InstallCheckConfig builder with application/json body
func NewInstallCheckConfigRequest(server string, body InstallCheckConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallCheckConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallCheckConfigRequestWithBody generates requests for InstallCheckConfig with any type of body
func NewInstallCheckConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/check_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallConfigureRequest calls the generic InstallConfigure builder with application/json body
func NewInstallConfigureRequest(server string, body InstallConfigureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallConfigureRequestWithBody(server, "application/json", bodyReader)
}

// NewInstallConfigureRequestWithBody generates requests for InstallConfigure with any type of body
func NewInstallConfigureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/configure")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstallGetAddressesRequest generates requests for InstallGetAddresses
func NewInstallGetAddressesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/install/get_addresses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParentalDisableRequest generates requests for ParentalDisable
func NewParentalDisableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parental/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParentalEnableRequest generates requests for ParentalEnable
func NewParentalEnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parental/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewParentalStatusRequest generates requests for ParentalStatus
func NewParentalStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/parental/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfileRequest generates requests for GetProfile
func NewGetProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProfileRequest calls the generic UpdateProfile builder with application/json body
func NewUpdateProfileRequest(server string, body UpdateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateProfileRequestWithBody generates requests for UpdateProfile with any type of body
func NewUpdateProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetProtectionRequest calls the generic SetProtection builder with application/json body
func NewSetProtectionRequest(server string, body SetProtectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetProtectionRequestWithBody(server, "application/json", bodyReader)
}

// NewSetProtectionRequestWithBody generates requests for SetProtection with any type of body
func NewSetProtectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/protection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryLogRequest generates requests for QueryLog
func NewQueryLogRequest(server string, params *QueryLogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OlderThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "older_than", runtime.ParamLocationQuery, *params.OlderThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_status", runtime.ParamLocationQuery, *params.ResponseStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQueryLogConfigRequest generates requests for GetQueryLogConfig
func NewGetQueryLogConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutQueryLogConfigRequest calls the generic PutQueryLogConfig builder with application/json body
func NewPutQueryLogConfigRequest(server string, body PutQueryLogConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutQueryLogConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewPutQueryLogConfigRequestWithBody generates requests for PutQueryLogConfig with any type of body
func NewPutQueryLogConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog/config/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQuerylogClearRequest generates requests for QuerylogClear
func NewQuerylogClearRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog_clear")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQueryLogConfigRequest calls the generic QueryLogConfig builder with application/json body
func NewQueryLogConfigRequest(server string, body QueryLogConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryLogConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryLogConfigRequestWithBody generates requests for QueryLogConfig with any type of body
func NewQueryLogConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryLogInfoRequest generates requests for QueryLogInfo
func NewQueryLogInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/querylog_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRewriteAddRequest calls the generic RewriteAdd builder with application/json body
func NewRewriteAddRequest(server string, body RewriteAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRewriteAddRequestWithBody(server, "application/json", bodyReader)
}

// NewRewriteAddRequestWithBody generates requests for RewriteAdd with any type of body
func NewRewriteAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/add")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRewriteDeleteRequest calls the generic RewriteDelete builder with application/json body
func NewRewriteDeleteRequest(server string, body RewriteDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRewriteDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewRewriteDeleteRequestWithBody generates requests for RewriteDelete with any type of body
func NewRewriteDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRewriteListRequest generates requests for RewriteList
func NewRewriteListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRewriteUpdateRequest calls the generic RewriteUpdate builder with application/json body
func NewRewriteUpdateRequest(server string, body RewriteUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRewriteUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewRewriteUpdateRequestWithBody generates requests for RewriteUpdate with any type of body
func NewRewriteUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rewrite/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSafebrowsingDisableRequest generates requests for SafebrowsingDisable
func NewSafebrowsingDisableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safebrowsing/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafebrowsingEnableRequest generates requests for SafebrowsingEnable
func NewSafebrowsingEnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safebrowsing/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafebrowsingStatusRequest generates requests for SafebrowsingStatus
func NewSafebrowsingStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safebrowsing/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafesearchDisableRequest generates requests for SafesearchDisable
func NewSafesearchDisableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafesearchEnableRequest generates requests for SafesearchEnable
func NewSafesearchEnableRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/enable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSafesearchSettingsRequest calls the generic SafesearchSettings builder with application/json body
func NewSafesearchSettingsRequest(server string, body SafesearchSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSafesearchSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewSafesearchSettingsRequestWithBody generates requests for SafesearchSettings with any type of body
func NewSafesearchSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSafesearchStatusRequest generates requests for SafesearchStatus
func NewSafesearchStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/safesearch/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsRequest generates requests for Stats
func NewStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsConfigRequest generates requests for GetStatsConfig
func NewGetStatsConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutStatsConfigRequest calls the generic PutStatsConfig builder with application/json body
func NewPutStatsConfigRequest(server string, body PutStatsConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutStatsConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewPutStatsConfigRequestWithBody generates requests for PutStatsConfig with any type of body
func NewPutStatsConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats/config/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStatsConfigRequest calls the generic StatsConfig builder with application/json body
func NewStatsConfigRequest(server string, body StatsConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStatsConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewStatsConfigRequestWithBody generates requests for StatsConfig with any type of body
func NewStatsConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats_config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStatsInfoRequest generates requests for StatsInfo
func NewStatsInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsResetRequest generates requests for StatsReset
func NewStatsResetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats_reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatusRequest generates requests for Status
func NewStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTestUpstreamDNSRequest calls the generic TestUpstreamDNS builder with application/json body
func NewTestUpstreamDNSRequest(server string, body TestUpstreamDNSJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestUpstreamDNSRequestWithBody(server, "application/json", bodyReader)
}

// NewTestUpstreamDNSRequestWithBody generates requests for TestUpstreamDNS with any type of body
func NewTestUpstreamDNSRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/test_upstream_dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTlsConfigureRequest calls the generic TlsConfigure builder with application/json body
func NewTlsConfigureRequest(server string, body TlsConfigureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTlsConfigureRequestWithBody(server, "application/json", bodyReader)
}

// NewTlsConfigureRequestWithBody generates requests for TlsConfigure with any type of body
func NewTlsConfigureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tls/configure")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTlsStatusRequest generates requests for TlsStatus
func NewTlsStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tls/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTlsValidateRequest calls the generic TlsValidate builder with application/json body
func NewTlsValidateRequest(server string, body TlsValidateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTlsValidateRequestWithBody(server, "application/json", bodyReader)
}

// NewTlsValidateRequestWithBody generates requests for TlsValidate with any type of body
func NewTlsValidateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tls/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBeginUpdateRequest generates requests for BeginUpdate
func NewBeginUpdateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionJsonRequest calls the generic GetVersionJson builder with application/json body
func NewGetVersionJsonRequest(server string, body GetVersionJsonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetVersionJsonRequestWithBody(server, "application/json", bodyReader)
}

// NewGetVersionJsonRequestWithBody generates requests for GetVersionJson with any type of body
func NewGetVersionJsonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *AdguardHomeClient) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *AdguardHomeClient) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AccessListWithResponse request
	AccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccessListResp, error)

	// AccessSetWithBodyWithResponse request with any body
	AccessSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccessSetResp, error)

	AccessSetWithResponse(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*AccessSetResp, error)

	// MobileConfigDoHWithResponse request
	MobileConfigDoHWithResponse(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*MobileConfigDoHResp, error)

	// MobileConfigDoTWithResponse request
	MobileConfigDoTWithResponse(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*MobileConfigDoTResp, error)

	// BlockedServicesAllWithResponse request
	BlockedServicesAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAllResp, error)

	// BlockedServicesScheduleWithResponse request
	BlockedServicesScheduleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesScheduleResp, error)

	// BlockedServicesListWithResponse request
	BlockedServicesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesListResp, error)

	// BlockedServicesAvailableServicesWithResponse request
	BlockedServicesAvailableServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAvailableServicesResp, error)

	// BlockedServicesSetWithBodyWithResponse request with any body
	BlockedServicesSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockedServicesSetResp, error)

	BlockedServicesSetWithResponse(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockedServicesSetResp, error)

	// BlockedServicesScheduleUpdateWithBodyWithResponse request with any body
	BlockedServicesScheduleUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockedServicesScheduleUpdateResp, error)

	BlockedServicesScheduleUpdateWithResponse(ctx context.Context, body BlockedServicesScheduleUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockedServicesScheduleUpdateResp, error)

	// CacheClearWithResponse request
	CacheClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CacheClearResp, error)

	// ClientsStatusWithResponse request
	ClientsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClientsStatusResp, error)

	// ClientsAddWithBodyWithResponse request with any body
	ClientsAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsAddResp, error)

	ClientsAddWithResponse(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsAddResp, error)

	// ClientsDeleteWithBodyWithResponse request with any body
	ClientsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsDeleteResp, error)

	ClientsDeleteWithResponse(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsDeleteResp, error)

	// ClientsFindWithResponse request
	ClientsFindWithResponse(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*ClientsFindResp, error)

	// ClientsUpdateWithBodyWithResponse request with any body
	ClientsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsUpdateResp, error)

	ClientsUpdateWithResponse(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsUpdateResp, error)

	// DhcpAddStaticLeaseWithBodyWithResponse request with any body
	DhcpAddStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResp, error)

	DhcpAddStaticLeaseWithResponse(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResp, error)

	// CheckActiveDhcpWithBodyWithResponse request with any body
	CheckActiveDhcpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResp, error)

	CheckActiveDhcpWithResponse(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResp, error)

	// DhcpInterfacesWithResponse request
	DhcpInterfacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpInterfacesResp, error)

	// DhcpRemoveStaticLeaseWithBodyWithResponse request with any body
	DhcpRemoveStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResp, error)

	DhcpRemoveStaticLeaseWithResponse(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResp, error)

	// DhcpResetWithResponse request
	DhcpResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetResp, error)

	// DhcpResetLeasesWithResponse request
	DhcpResetLeasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetLeasesResp, error)

	// DhcpSetConfigWithBodyWithResponse request with any body
	DhcpSetConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpSetConfigResp, error)

	DhcpSetConfigWithResponse(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpSetConfigResp, error)

	// DhcpStatusWithResponse request
	DhcpStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpStatusResp, error)

	// DhcpUpdateStaticLeaseWithBodyWithResponse request with any body
	DhcpUpdateStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpUpdateStaticLeaseResp, error)

	DhcpUpdateStaticLeaseWithResponse(ctx context.Context, body DhcpUpdateStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpUpdateStaticLeaseResp, error)

	// DnsConfigWithBodyWithResponse request with any body
	DnsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsConfigResp, error)

	DnsConfigWithResponse(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsConfigResp, error)

	// DnsInfoWithResponse request
	DnsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DnsInfoResp, error)

	// FilteringAddURLWithBodyWithResponse request with any body
	FilteringAddURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringAddURLResp, error)

	FilteringAddURLWithResponse(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringAddURLResp, error)

	// FilteringCheckHostWithResponse request
	FilteringCheckHostWithResponse(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*FilteringCheckHostResp, error)

	// FilteringConfigWithBodyWithResponse request with any body
	FilteringConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringConfigResp, error)

	FilteringConfigWithResponse(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringConfigResp, error)

	// FilteringRefreshWithBodyWithResponse request with any body
	FilteringRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRefreshResp, error)

	FilteringRefreshWithResponse(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRefreshResp, error)

	// FilteringRemoveURLWithBodyWithResponse request with any body
	FilteringRemoveURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResp, error)

	FilteringRemoveURLWithResponse(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResp, error)

	// FilteringSetRulesWithBodyWithResponse request with any body
	FilteringSetRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetRulesResp, error)

	FilteringSetRulesWithResponse(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetRulesResp, error)

	// FilteringSetURLWithBodyWithResponse request with any body
	FilteringSetURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetURLResp, error)

	FilteringSetURLWithResponse(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetURLResp, error)

	// FilteringStatusWithResponse request
	FilteringStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FilteringStatusResp, error)

	// ChangeLanguageWithBodyWithResponse request with any body
	ChangeLanguageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeLanguageResp, error)

	ChangeLanguageWithResponse(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeLanguageResp, error)

	// CurrentLanguageWithResponse request
	CurrentLanguageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentLanguageResp, error)

	// InstallCheckConfigWithBodyWithResponse request with any body
	InstallCheckConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallCheckConfigResp, error)

	InstallCheckConfigWithResponse(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallCheckConfigResp, error)

	// InstallConfigureWithBodyWithResponse request with any body
	InstallConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallConfigureResp, error)

	InstallConfigureWithResponse(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallConfigureResp, error)

	// InstallGetAddressesWithResponse request
	InstallGetAddressesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstallGetAddressesResp, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResp, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResp, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResp, error)

	// ParentalDisableWithResponse request
	ParentalDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalDisableResp, error)

	// ParentalEnableWithResponse request
	ParentalEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalEnableResp, error)

	// ParentalStatusWithResponse request
	ParentalStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalStatusResp, error)

	// GetProfileWithResponse request
	GetProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProfileResp, error)

	// UpdateProfileWithBodyWithResponse request with any body
	UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResp, error)

	UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResp, error)

	// SetProtectionWithBodyWithResponse request with any body
	SetProtectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetProtectionResp, error)

	SetProtectionWithResponse(ctx context.Context, body SetProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetProtectionResp, error)

	// QueryLogWithResponse request
	QueryLogWithResponse(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*QueryLogResp, error)

	// GetQueryLogConfigWithResponse request
	GetQueryLogConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQueryLogConfigResp, error)

	// PutQueryLogConfigWithBodyWithResponse request with any body
	PutQueryLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutQueryLogConfigResp, error)

	PutQueryLogConfigWithResponse(ctx context.Context, body PutQueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PutQueryLogConfigResp, error)

	// QuerylogClearWithResponse request
	QuerylogClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QuerylogClearResp, error)

	// QueryLogConfigWithBodyWithResponse request with any body
	QueryLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryLogConfigResp, error)

	QueryLogConfigWithResponse(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryLogConfigResp, error)

	// QueryLogInfoWithResponse request
	QueryLogInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryLogInfoResp, error)

	// RewriteAddWithBodyWithResponse request with any body
	RewriteAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteAddResp, error)

	RewriteAddWithResponse(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteAddResp, error)

	// RewriteDeleteWithBodyWithResponse request with any body
	RewriteDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteDeleteResp, error)

	RewriteDeleteWithResponse(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteDeleteResp, error)

	// RewriteListWithResponse request
	RewriteListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RewriteListResp, error)

	// RewriteUpdateWithBodyWithResponse request with any body
	RewriteUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteUpdateResp, error)

	RewriteUpdateWithResponse(ctx context.Context, body RewriteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteUpdateResp, error)

	// SafebrowsingDisableWithResponse request
	SafebrowsingDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingDisableResp, error)

	// SafebrowsingEnableWithResponse request
	SafebrowsingEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingEnableResp, error)

	// SafebrowsingStatusWithResponse request
	SafebrowsingStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingStatusResp, error)

	// SafesearchDisableWithResponse request
	SafesearchDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchDisableResp, error)

	// SafesearchEnableWithResponse request
	SafesearchEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchEnableResp, error)

	// SafesearchSettingsWithBodyWithResponse request with any body
	SafesearchSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SafesearchSettingsResp, error)

	SafesearchSettingsWithResponse(ctx context.Context, body SafesearchSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SafesearchSettingsResp, error)

	// SafesearchStatusWithResponse request
	SafesearchStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchStatusResp, error)

	// StatsWithResponse request
	StatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResp, error)

	// GetStatsConfigWithResponse request
	GetStatsConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsConfigResp, error)

	// PutStatsConfigWithBodyWithResponse request with any body
	PutStatsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutStatsConfigResp, error)

	PutStatsConfigWithResponse(ctx context.Context, body PutStatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PutStatsConfigResp, error)

	// StatsConfigWithBodyWithResponse request with any body
	StatsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StatsConfigResp, error)

	StatsConfigWithResponse(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*StatsConfigResp, error)

	// StatsInfoWithResponse request
	StatsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsInfoResp, error)

	// StatsResetWithResponse request
	StatsResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResetResp, error)

	// StatusWithResponse request
	StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResp, error)

	// TestUpstreamDNSWithBodyWithResponse request with any body
	TestUpstreamDNSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResp, error)

	TestUpstreamDNSWithResponse(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResp, error)

	// TlsConfigureWithBodyWithResponse request with any body
	TlsConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsConfigureResp, error)

	TlsConfigureWithResponse(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsConfigureResp, error)

	// TlsStatusWithResponse request
	TlsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TlsStatusResp, error)

	// TlsValidateWithBodyWithResponse request with any body
	TlsValidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsValidateResp, error)

	TlsValidateWithResponse(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsValidateResp, error)

	// BeginUpdateWithResponse request
	BeginUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BeginUpdateResp, error)

	// GetVersionJsonWithBodyWithResponse request with any body
	GetVersionJsonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionJsonResp, error)

	GetVersionJsonWithResponse(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionJsonResp, error)
}

type AccessListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessListResponse
}

// Status returns HTTPResponse.Status
func (r AccessListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccessListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccessSetResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AccessSetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccessSetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MobileConfigDoHResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r MobileConfigDoHResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MobileConfigDoHResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MobileConfigDoTResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r MobileConfigDoTResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MobileConfigDoTResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesAllResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesAll
}

// Status returns HTTPResponse.Status
func (r BlockedServicesAllResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesAllResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesScheduleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesSchedule
}

// Status returns HTTPResponse.Status
func (r BlockedServicesScheduleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesScheduleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesArray
}

// Status returns HTTPResponse.Status
func (r BlockedServicesListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesAvailableServicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockedServicesArray
}

// Status returns HTTPResponse.Status
func (r BlockedServicesAvailableServicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesAvailableServicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesSetResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BlockedServicesSetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesSetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockedServicesScheduleUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BlockedServicesScheduleUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockedServicesScheduleUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheClearResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CacheClearResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheClearResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Clients
}

// Status returns HTTPResponse.Status
func (r ClientsStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsAddResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClientsAddResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsAddResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsDeleteResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClientsDeleteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsDeleteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsFindResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientsFindResponse
}

// Status returns HTTPResponse.Status
func (r ClientsFindResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsFindResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClientsUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClientsUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClientsUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpAddStaticLeaseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpAddStaticLeaseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpAddStaticLeaseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckActiveDhcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DhcpSearchResult
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r CheckActiveDhcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckActiveDhcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpInterfacesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetInterfaces
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpInterfacesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpInterfacesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpRemoveStaticLeaseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpRemoveStaticLeaseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpRemoveStaticLeaseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpResetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpResetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpResetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpResetLeasesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpResetLeasesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpResetLeasesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpSetConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpSetConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpSetConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DhcpStatus
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DhcpUpdateStaticLeaseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON501      *Error
}

// Status returns HTTPResponse.Status
func (r DhcpUpdateStaticLeaseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DhcpUpdateStaticLeaseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DnsConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DnsInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DNSConfig
}

// Status returns HTTPResponse.Status
func (r DnsInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DnsInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringAddURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringAddURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringAddURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringCheckHostResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterCheckHostResponse
}

// Status returns HTTPResponse.Status
func (r FilteringCheckHostResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringCheckHostResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringRefreshResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterRefreshResponse
}

// Status returns HTTPResponse.Status
func (r FilteringRefreshResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringRefreshResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringRemoveURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringRemoveURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringRemoveURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringSetRulesResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringSetRulesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringSetRulesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringSetURLResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilteringSetURLResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringSetURLResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilteringStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FilterStatus
}

// Status returns HTTPResponse.Status
func (r FilteringStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilteringStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeLanguageResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ChangeLanguageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeLanguageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentLanguageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LanguageSettings
}

// Status returns HTTPResponse.Status
func (r CurrentLanguageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentLanguageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallCheckConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckConfigResponse
}

// Status returns HTTPResponse.Status
func (r InstallCheckConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallCheckConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallConfigureResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallConfigureResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallConfigureResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallGetAddressesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddressesInfo
}

// Status returns HTTPResponse.Status
func (r InstallGetAddressesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallGetAddressesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParentalDisableResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ParentalDisableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParentalDisableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParentalEnableResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ParentalEnableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParentalEnableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ParentalStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Enable      *bool `json:"enable,omitempty"`
		Sensitivity *int  `json:"sensitivity,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ParentalStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ParentalStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileInfo
}

// Status returns HTTPResponse.Status
func (r GetProfileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetProtectionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetProtectionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetProtectionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryLogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryLog
}

// Status returns HTTPResponse.Status
func (r QueryLogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryLogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQueryLogConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetQueryLogConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetQueryLogConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQueryLogConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutQueryLogConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutQueryLogConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutQueryLogConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QuerylogClearResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QuerylogClearResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuerylogClearResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryLogConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r QueryLogConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryLogConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryLogInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryLogConfig
}

// Status returns HTTPResponse.Status
func (r QueryLogInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryLogInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteAddResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RewriteAddResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteAddResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteDeleteResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RewriteDeleteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteDeleteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RewriteList
}

// Status returns HTTPResponse.Status
func (r RewriteListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RewriteUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RewriteUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RewriteUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafebrowsingDisableResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafebrowsingDisableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafebrowsingDisableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafebrowsingEnableResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafebrowsingEnableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafebrowsingEnableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafebrowsingStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Enabled *bool `json:"enabled,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SafebrowsingStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafebrowsingStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchDisableResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafesearchDisableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchDisableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchEnableResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafesearchEnableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchEnableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchSettingsResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SafesearchSettingsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchSettingsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SafesearchStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SafeSearchConfig
}

// Status returns HTTPResponse.Status
func (r SafesearchStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SafesearchStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stats
}

// Status returns HTTPResponse.Status
func (r StatsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStatsConfigResponse
}

// Status returns HTTPResponse.Status
func (r GetStatsConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutStatsConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutStatsConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutStatsConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsConfigResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatsConfigResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsConfigResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsInfoResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatsConfig
}

// Status returns HTTPResponse.Status
func (r StatsInfoResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsInfoResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsResetResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatsResetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsResetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerStatus
}

// Status returns HTTPResponse.Status
func (r StatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestUpstreamDNSResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpstreamsConfigResponse
}

// Status returns HTTPResponse.Status
func (r TestUpstreamDNSResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestUpstreamDNSResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TlsConfigureResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsConfig
}

// Status returns HTTPResponse.Status
func (r TlsConfigureResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TlsConfigureResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TlsStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsConfig
}

// Status returns HTTPResponse.Status
func (r TlsStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TlsStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TlsValidateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsConfig
}

// Status returns HTTPResponse.Status
func (r TlsValidateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TlsValidateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BeginUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BeginUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BeginUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionJsonResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionInfo
}

// Status returns HTTPResponse.Status
func (r GetVersionJsonResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionJsonResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AccessListWithResponse request returning *AccessListResp
func (c *ClientWithResponses) AccessListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AccessListResp, error) {
	rsp, err := c.AccessList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccessListResp(rsp)
}

// AccessSetWithBodyWithResponse request with arbitrary body returning *AccessSetResp
func (c *ClientWithResponses) AccessSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AccessSetResp, error) {
	rsp, err := c.AccessSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccessSetResp(rsp)
}

func (c *ClientWithResponses) AccessSetWithResponse(ctx context.Context, body AccessSetJSONRequestBody, reqEditors ...RequestEditorFn) (*AccessSetResp, error) {
	rsp, err := c.AccessSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccessSetResp(rsp)
}

// MobileConfigDoHWithResponse request returning *MobileConfigDoHResp
func (c *ClientWithResponses) MobileConfigDoHWithResponse(ctx context.Context, params *MobileConfigDoHParams, reqEditors ...RequestEditorFn) (*MobileConfigDoHResp, error) {
	rsp, err := c.MobileConfigDoH(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMobileConfigDoHResp(rsp)
}

// MobileConfigDoTWithResponse request returning *MobileConfigDoTResp
func (c *ClientWithResponses) MobileConfigDoTWithResponse(ctx context.Context, params *MobileConfigDoTParams, reqEditors ...RequestEditorFn) (*MobileConfigDoTResp, error) {
	rsp, err := c.MobileConfigDoT(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMobileConfigDoTResp(rsp)
}

// BlockedServicesAllWithResponse request returning *BlockedServicesAllResp
func (c *ClientWithResponses) BlockedServicesAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAllResp, error) {
	rsp, err := c.BlockedServicesAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesAllResp(rsp)
}

// BlockedServicesScheduleWithResponse request returning *BlockedServicesScheduleResp
func (c *ClientWithResponses) BlockedServicesScheduleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesScheduleResp, error) {
	rsp, err := c.BlockedServicesSchedule(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesScheduleResp(rsp)
}

// BlockedServicesListWithResponse request returning *BlockedServicesListResp
func (c *ClientWithResponses) BlockedServicesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesListResp, error) {
	rsp, err := c.BlockedServicesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesListResp(rsp)
}

// BlockedServicesAvailableServicesWithResponse request returning *BlockedServicesAvailableServicesResp
func (c *ClientWithResponses) BlockedServicesAvailableServicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BlockedServicesAvailableServicesResp, error) {
	rsp, err := c.BlockedServicesAvailableServices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesAvailableServicesResp(rsp)
}

// BlockedServicesSetWithBodyWithResponse request with arbitrary body returning *BlockedServicesSetResp
func (c *ClientWithResponses) BlockedServicesSetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockedServicesSetResp, error) {
	rsp, err := c.BlockedServicesSetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesSetResp(rsp)
}

func (c *ClientWithResponses) BlockedServicesSetWithResponse(ctx context.Context, body BlockedServicesSetJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockedServicesSetResp, error) {
	rsp, err := c.BlockedServicesSet(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesSetResp(rsp)
}

// BlockedServicesScheduleUpdateWithBodyWithResponse request with arbitrary body returning *BlockedServicesScheduleUpdateResp
func (c *ClientWithResponses) BlockedServicesScheduleUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BlockedServicesScheduleUpdateResp, error) {
	rsp, err := c.BlockedServicesScheduleUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesScheduleUpdateResp(rsp)
}

func (c *ClientWithResponses) BlockedServicesScheduleUpdateWithResponse(ctx context.Context, body BlockedServicesScheduleUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*BlockedServicesScheduleUpdateResp, error) {
	rsp, err := c.BlockedServicesScheduleUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockedServicesScheduleUpdateResp(rsp)
}

// CacheClearWithResponse request returning *CacheClearResp
func (c *ClientWithResponses) CacheClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CacheClearResp, error) {
	rsp, err := c.CacheClear(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheClearResp(rsp)
}

// ClientsStatusWithResponse request returning *ClientsStatusResp
func (c *ClientWithResponses) ClientsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClientsStatusResp, error) {
	rsp, err := c.ClientsStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsStatusResp(rsp)
}

// ClientsAddWithBodyWithResponse request with arbitrary body returning *ClientsAddResp
func (c *ClientWithResponses) ClientsAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsAddResp, error) {
	rsp, err := c.ClientsAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsAddResp(rsp)
}

func (c *ClientWithResponses) ClientsAddWithResponse(ctx context.Context, body ClientsAddJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsAddResp, error) {
	rsp, err := c.ClientsAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsAddResp(rsp)
}

// ClientsDeleteWithBodyWithResponse request with arbitrary body returning *ClientsDeleteResp
func (c *ClientWithResponses) ClientsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsDeleteResp, error) {
	rsp, err := c.ClientsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsDeleteResp(rsp)
}

func (c *ClientWithResponses) ClientsDeleteWithResponse(ctx context.Context, body ClientsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsDeleteResp, error) {
	rsp, err := c.ClientsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsDeleteResp(rsp)
}

// ClientsFindWithResponse request returning *ClientsFindResp
func (c *ClientWithResponses) ClientsFindWithResponse(ctx context.Context, params *ClientsFindParams, reqEditors ...RequestEditorFn) (*ClientsFindResp, error) {
	rsp, err := c.ClientsFind(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsFindResp(rsp)
}

// ClientsUpdateWithBodyWithResponse request with arbitrary body returning *ClientsUpdateResp
func (c *ClientWithResponses) ClientsUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClientsUpdateResp, error) {
	rsp, err := c.ClientsUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsUpdateResp(rsp)
}

func (c *ClientWithResponses) ClientsUpdateWithResponse(ctx context.Context, body ClientsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ClientsUpdateResp, error) {
	rsp, err := c.ClientsUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClientsUpdateResp(rsp)
}

// DhcpAddStaticLeaseWithBodyWithResponse request with arbitrary body returning *DhcpAddStaticLeaseResp
func (c *ClientWithResponses) DhcpAddStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResp, error) {
	rsp, err := c.DhcpAddStaticLeaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpAddStaticLeaseResp(rsp)
}

func (c *ClientWithResponses) DhcpAddStaticLeaseWithResponse(ctx context.Context, body DhcpAddStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpAddStaticLeaseResp, error) {
	rsp, err := c.DhcpAddStaticLease(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpAddStaticLeaseResp(rsp)
}

// CheckActiveDhcpWithBodyWithResponse request with arbitrary body returning *CheckActiveDhcpResp
func (c *ClientWithResponses) CheckActiveDhcpWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResp, error) {
	rsp, err := c.CheckActiveDhcpWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckActiveDhcpResp(rsp)
}

func (c *ClientWithResponses) CheckActiveDhcpWithResponse(ctx context.Context, body CheckActiveDhcpJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckActiveDhcpResp, error) {
	rsp, err := c.CheckActiveDhcp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckActiveDhcpResp(rsp)
}

// DhcpInterfacesWithResponse request returning *DhcpInterfacesResp
func (c *ClientWithResponses) DhcpInterfacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpInterfacesResp, error) {
	rsp, err := c.DhcpInterfaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpInterfacesResp(rsp)
}

// DhcpRemoveStaticLeaseWithBodyWithResponse request with arbitrary body returning *DhcpRemoveStaticLeaseResp
func (c *ClientWithResponses) DhcpRemoveStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResp, error) {
	rsp, err := c.DhcpRemoveStaticLeaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpRemoveStaticLeaseResp(rsp)
}

func (c *ClientWithResponses) DhcpRemoveStaticLeaseWithResponse(ctx context.Context, body DhcpRemoveStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpRemoveStaticLeaseResp, error) {
	rsp, err := c.DhcpRemoveStaticLease(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpRemoveStaticLeaseResp(rsp)
}

// DhcpResetWithResponse request returning *DhcpResetResp
func (c *ClientWithResponses) DhcpResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetResp, error) {
	rsp, err := c.DhcpReset(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpResetResp(rsp)
}

// DhcpResetLeasesWithResponse request returning *DhcpResetLeasesResp
func (c *ClientWithResponses) DhcpResetLeasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpResetLeasesResp, error) {
	rsp, err := c.DhcpResetLeases(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpResetLeasesResp(rsp)
}

// DhcpSetConfigWithBodyWithResponse request with arbitrary body returning *DhcpSetConfigResp
func (c *ClientWithResponses) DhcpSetConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpSetConfigResp, error) {
	rsp, err := c.DhcpSetConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpSetConfigResp(rsp)
}

func (c *ClientWithResponses) DhcpSetConfigWithResponse(ctx context.Context, body DhcpSetConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpSetConfigResp, error) {
	rsp, err := c.DhcpSetConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpSetConfigResp(rsp)
}

// DhcpStatusWithResponse request returning *DhcpStatusResp
func (c *ClientWithResponses) DhcpStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DhcpStatusResp, error) {
	rsp, err := c.DhcpStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpStatusResp(rsp)
}

// DhcpUpdateStaticLeaseWithBodyWithResponse request with arbitrary body returning *DhcpUpdateStaticLeaseResp
func (c *ClientWithResponses) DhcpUpdateStaticLeaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DhcpUpdateStaticLeaseResp, error) {
	rsp, err := c.DhcpUpdateStaticLeaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpUpdateStaticLeaseResp(rsp)
}

func (c *ClientWithResponses) DhcpUpdateStaticLeaseWithResponse(ctx context.Context, body DhcpUpdateStaticLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*DhcpUpdateStaticLeaseResp, error) {
	rsp, err := c.DhcpUpdateStaticLease(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDhcpUpdateStaticLeaseResp(rsp)
}

// DnsConfigWithBodyWithResponse request with arbitrary body returning *DnsConfigResp
func (c *ClientWithResponses) DnsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DnsConfigResp, error) {
	rsp, err := c.DnsConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsConfigResp(rsp)
}

func (c *ClientWithResponses) DnsConfigWithResponse(ctx context.Context, body DnsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*DnsConfigResp, error) {
	rsp, err := c.DnsConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsConfigResp(rsp)
}

// DnsInfoWithResponse request returning *DnsInfoResp
func (c *ClientWithResponses) DnsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DnsInfoResp, error) {
	rsp, err := c.DnsInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDnsInfoResp(rsp)
}

// FilteringAddURLWithBodyWithResponse request with arbitrary body returning *FilteringAddURLResp
func (c *ClientWithResponses) FilteringAddURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringAddURLResp, error) {
	rsp, err := c.FilteringAddURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringAddURLResp(rsp)
}

func (c *ClientWithResponses) FilteringAddURLWithResponse(ctx context.Context, body FilteringAddURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringAddURLResp, error) {
	rsp, err := c.FilteringAddURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringAddURLResp(rsp)
}

// FilteringCheckHostWithResponse request returning *FilteringCheckHostResp
func (c *ClientWithResponses) FilteringCheckHostWithResponse(ctx context.Context, params *FilteringCheckHostParams, reqEditors ...RequestEditorFn) (*FilteringCheckHostResp, error) {
	rsp, err := c.FilteringCheckHost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringCheckHostResp(rsp)
}

// FilteringConfigWithBodyWithResponse request with arbitrary body returning *FilteringConfigResp
func (c *ClientWithResponses) FilteringConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringConfigResp, error) {
	rsp, err := c.FilteringConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringConfigResp(rsp)
}

func (c *ClientWithResponses) FilteringConfigWithResponse(ctx context.Context, body FilteringConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringConfigResp, error) {
	rsp, err := c.FilteringConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringConfigResp(rsp)
}

// FilteringRefreshWithBodyWithResponse request with arbitrary body returning *FilteringRefreshResp
func (c *ClientWithResponses) FilteringRefreshWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRefreshResp, error) {
	rsp, err := c.FilteringRefreshWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRefreshResp(rsp)
}

func (c *ClientWithResponses) FilteringRefreshWithResponse(ctx context.Context, body FilteringRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRefreshResp, error) {
	rsp, err := c.FilteringRefresh(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRefreshResp(rsp)
}

// FilteringRemoveURLWithBodyWithResponse request with arbitrary body returning *FilteringRemoveURLResp
func (c *ClientWithResponses) FilteringRemoveURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResp, error) {
	rsp, err := c.FilteringRemoveURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRemoveURLResp(rsp)
}

func (c *ClientWithResponses) FilteringRemoveURLWithResponse(ctx context.Context, body FilteringRemoveURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringRemoveURLResp, error) {
	rsp, err := c.FilteringRemoveURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringRemoveURLResp(rsp)
}

// FilteringSetRulesWithBodyWithResponse request with arbitrary body returning *FilteringSetRulesResp
func (c *ClientWithResponses) FilteringSetRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetRulesResp, error) {
	rsp, err := c.FilteringSetRulesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetRulesResp(rsp)
}

func (c *ClientWithResponses) FilteringSetRulesWithResponse(ctx context.Context, body FilteringSetRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetRulesResp, error) {
	rsp, err := c.FilteringSetRules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetRulesResp(rsp)
}

// FilteringSetURLWithBodyWithResponse request with arbitrary body returning *FilteringSetURLResp
func (c *ClientWithResponses) FilteringSetURLWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilteringSetURLResp, error) {
	rsp, err := c.FilteringSetURLWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetURLResp(rsp)
}

func (c *ClientWithResponses) FilteringSetURLWithResponse(ctx context.Context, body FilteringSetURLJSONRequestBody, reqEditors ...RequestEditorFn) (*FilteringSetURLResp, error) {
	rsp, err := c.FilteringSetURL(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringSetURLResp(rsp)
}

// FilteringStatusWithResponse request returning *FilteringStatusResp
func (c *ClientWithResponses) FilteringStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FilteringStatusResp, error) {
	rsp, err := c.FilteringStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilteringStatusResp(rsp)
}

// ChangeLanguageWithBodyWithResponse request with arbitrary body returning *ChangeLanguageResp
func (c *ClientWithResponses) ChangeLanguageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeLanguageResp, error) {
	rsp, err := c.ChangeLanguageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeLanguageResp(rsp)
}

func (c *ClientWithResponses) ChangeLanguageWithResponse(ctx context.Context, body ChangeLanguageJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeLanguageResp, error) {
	rsp, err := c.ChangeLanguage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeLanguageResp(rsp)
}

// CurrentLanguageWithResponse request returning *CurrentLanguageResp
func (c *ClientWithResponses) CurrentLanguageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentLanguageResp, error) {
	rsp, err := c.CurrentLanguage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentLanguageResp(rsp)
}

// InstallCheckConfigWithBodyWithResponse request with arbitrary body returning *InstallCheckConfigResp
func (c *ClientWithResponses) InstallCheckConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallCheckConfigResp, error) {
	rsp, err := c.InstallCheckConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallCheckConfigResp(rsp)
}

func (c *ClientWithResponses) InstallCheckConfigWithResponse(ctx context.Context, body InstallCheckConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallCheckConfigResp, error) {
	rsp, err := c.InstallCheckConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallCheckConfigResp(rsp)
}

// InstallConfigureWithBodyWithResponse request with arbitrary body returning *InstallConfigureResp
func (c *ClientWithResponses) InstallConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallConfigureResp, error) {
	rsp, err := c.InstallConfigureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallConfigureResp(rsp)
}

func (c *ClientWithResponses) InstallConfigureWithResponse(ctx context.Context, body InstallConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallConfigureResp, error) {
	rsp, err := c.InstallConfigure(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallConfigureResp(rsp)
}

// InstallGetAddressesWithResponse request returning *InstallGetAddressesResp
func (c *ClientWithResponses) InstallGetAddressesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstallGetAddressesResp, error) {
	rsp, err := c.InstallGetAddresses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallGetAddressesResp(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResp
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResp, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResp(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResp, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResp(rsp)
}

// LogoutWithResponse request returning *LogoutResp
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResp, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResp(rsp)
}

// ParentalDisableWithResponse request returning *ParentalDisableResp
func (c *ClientWithResponses) ParentalDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalDisableResp, error) {
	rsp, err := c.ParentalDisable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParentalDisableResp(rsp)
}

// ParentalEnableWithResponse request returning *ParentalEnableResp
func (c *ClientWithResponses) ParentalEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalEnableResp, error) {
	rsp, err := c.ParentalEnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParentalEnableResp(rsp)
}

// ParentalStatusWithResponse request returning *ParentalStatusResp
func (c *ClientWithResponses) ParentalStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ParentalStatusResp, error) {
	rsp, err := c.ParentalStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseParentalStatusResp(rsp)
}

// GetProfileWithResponse request returning *GetProfileResp
func (c *ClientWithResponses) GetProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProfileResp, error) {
	rsp, err := c.GetProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfileResp(rsp)
}

// UpdateProfileWithBodyWithResponse request with arbitrary body returning *UpdateProfileResp
func (c *ClientWithResponses) UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResp, error) {
	rsp, err := c.UpdateProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResp(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResp, error) {
	rsp, err := c.UpdateProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResp(rsp)
}

// SetProtectionWithBodyWithResponse request with arbitrary body returning *SetProtectionResp
func (c *ClientWithResponses) SetProtectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetProtectionResp, error) {
	rsp, err := c.SetProtectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetProtectionResp(rsp)
}

func (c *ClientWithResponses) SetProtectionWithResponse(ctx context.Context, body SetProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*SetProtectionResp, error) {
	rsp, err := c.SetProtection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetProtectionResp(rsp)
}

// QueryLogWithResponse request returning *QueryLogResp
func (c *ClientWithResponses) QueryLogWithResponse(ctx context.Context, params *QueryLogParams, reqEditors ...RequestEditorFn) (*QueryLogResp, error) {
	rsp, err := c.QueryLog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogResp(rsp)
}

// GetQueryLogConfigWithResponse request returning *GetQueryLogConfigResp
func (c *ClientWithResponses) GetQueryLogConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetQueryLogConfigResp, error) {
	rsp, err := c.GetQueryLogConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQueryLogConfigResp(rsp)
}

// PutQueryLogConfigWithBodyWithResponse request with arbitrary body returning *PutQueryLogConfigResp
func (c *ClientWithResponses) PutQueryLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutQueryLogConfigResp, error) {
	rsp, err := c.PutQueryLogConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutQueryLogConfigResp(rsp)
}

func (c *ClientWithResponses) PutQueryLogConfigWithResponse(ctx context.Context, body PutQueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PutQueryLogConfigResp, error) {
	rsp, err := c.PutQueryLogConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutQueryLogConfigResp(rsp)
}

// QuerylogClearWithResponse request returning *QuerylogClearResp
func (c *ClientWithResponses) QuerylogClearWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QuerylogClearResp, error) {
	rsp, err := c.QuerylogClear(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerylogClearResp(rsp)
}

// QueryLogConfigWithBodyWithResponse request with arbitrary body returning *QueryLogConfigResp
func (c *ClientWithResponses) QueryLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryLogConfigResp, error) {
	rsp, err := c.QueryLogConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogConfigResp(rsp)
}

func (c *ClientWithResponses) QueryLogConfigWithResponse(ctx context.Context, body QueryLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryLogConfigResp, error) {
	rsp, err := c.QueryLogConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogConfigResp(rsp)
}

// QueryLogInfoWithResponse request returning *QueryLogInfoResp
func (c *ClientWithResponses) QueryLogInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*QueryLogInfoResp, error) {
	rsp, err := c.QueryLogInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryLogInfoResp(rsp)
}

// RewriteAddWithBodyWithResponse request with arbitrary body returning *RewriteAddResp
func (c *ClientWithResponses) RewriteAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteAddResp, error) {
	rsp, err := c.RewriteAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteAddResp(rsp)
}

func (c *ClientWithResponses) RewriteAddWithResponse(ctx context.Context, body RewriteAddJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteAddResp, error) {
	rsp, err := c.RewriteAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteAddResp(rsp)
}

// RewriteDeleteWithBodyWithResponse request with arbitrary body returning *RewriteDeleteResp
func (c *ClientWithResponses) RewriteDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteDeleteResp, error) {
	rsp, err := c.RewriteDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteDeleteResp(rsp)
}

func (c *ClientWithResponses) RewriteDeleteWithResponse(ctx context.Context, body RewriteDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteDeleteResp, error) {
	rsp, err := c.RewriteDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteDeleteResp(rsp)
}

// RewriteListWithResponse request returning *RewriteListResp
func (c *ClientWithResponses) RewriteListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RewriteListResp, error) {
	rsp, err := c.RewriteList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteListResp(rsp)
}

// RewriteUpdateWithBodyWithResponse request with arbitrary body returning *RewriteUpdateResp
func (c *ClientWithResponses) RewriteUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RewriteUpdateResp, error) {
	rsp, err := c.RewriteUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteUpdateResp(rsp)
}

func (c *ClientWithResponses) RewriteUpdateWithResponse(ctx context.Context, body RewriteUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*RewriteUpdateResp, error) {
	rsp, err := c.RewriteUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRewriteUpdateResp(rsp)
}

// SafebrowsingDisableWithResponse request returning *SafebrowsingDisableResp
func (c *ClientWithResponses) SafebrowsingDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingDisableResp, error) {
	rsp, err := c.SafebrowsingDisable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafebrowsingDisableResp(rsp)
}

// SafebrowsingEnableWithResponse request returning *SafebrowsingEnableResp
func (c *ClientWithResponses) SafebrowsingEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingEnableResp, error) {
	rsp, err := c.SafebrowsingEnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafebrowsingEnableResp(rsp)
}

// SafebrowsingStatusWithResponse request returning *SafebrowsingStatusResp
func (c *ClientWithResponses) SafebrowsingStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafebrowsingStatusResp, error) {
	rsp, err := c.SafebrowsingStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafebrowsingStatusResp(rsp)
}

// SafesearchDisableWithResponse request returning *SafesearchDisableResp
func (c *ClientWithResponses) SafesearchDisableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchDisableResp, error) {
	rsp, err := c.SafesearchDisable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchDisableResp(rsp)
}

// SafesearchEnableWithResponse request returning *SafesearchEnableResp
func (c *ClientWithResponses) SafesearchEnableWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchEnableResp, error) {
	rsp, err := c.SafesearchEnable(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchEnableResp(rsp)
}

// SafesearchSettingsWithBodyWithResponse request with arbitrary body returning *SafesearchSettingsResp
func (c *ClientWithResponses) SafesearchSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SafesearchSettingsResp, error) {
	rsp, err := c.SafesearchSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchSettingsResp(rsp)
}

func (c *ClientWithResponses) SafesearchSettingsWithResponse(ctx context.Context, body SafesearchSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*SafesearchSettingsResp, error) {
	rsp, err := c.SafesearchSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchSettingsResp(rsp)
}

// SafesearchStatusWithResponse request returning *SafesearchStatusResp
func (c *ClientWithResponses) SafesearchStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SafesearchStatusResp, error) {
	rsp, err := c.SafesearchStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSafesearchStatusResp(rsp)
}

// StatsWithResponse request returning *StatsResp
func (c *ClientWithResponses) StatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResp, error) {
	rsp, err := c.Stats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsResp(rsp)
}

// GetStatsConfigWithResponse request returning *GetStatsConfigResp
func (c *ClientWithResponses) GetStatsConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsConfigResp, error) {
	rsp, err := c.GetStatsConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsConfigResp(rsp)
}

// PutStatsConfigWithBodyWithResponse request with arbitrary body returning *PutStatsConfigResp
func (c *ClientWithResponses) PutStatsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutStatsConfigResp, error) {
	rsp, err := c.PutStatsConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStatsConfigResp(rsp)
}

func (c *ClientWithResponses) PutStatsConfigWithResponse(ctx context.Context, body PutStatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*PutStatsConfigResp, error) {
	rsp, err := c.PutStatsConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStatsConfigResp(rsp)
}

// StatsConfigWithBodyWithResponse request with arbitrary body returning *StatsConfigResp
func (c *ClientWithResponses) StatsConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StatsConfigResp, error) {
	rsp, err := c.StatsConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsConfigResp(rsp)
}

func (c *ClientWithResponses) StatsConfigWithResponse(ctx context.Context, body StatsConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*StatsConfigResp, error) {
	rsp, err := c.StatsConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsConfigResp(rsp)
}

// StatsInfoWithResponse request returning *StatsInfoResp
func (c *ClientWithResponses) StatsInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsInfoResp, error) {
	rsp, err := c.StatsInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsInfoResp(rsp)
}

// StatsResetWithResponse request returning *StatsResetResp
func (c *ClientWithResponses) StatsResetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatsResetResp, error) {
	rsp, err := c.StatsReset(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsResetResp(rsp)
}

// StatusWithResponse request returning *StatusResp
func (c *ClientWithResponses) StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResp, error) {
	rsp, err := c.Status(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusResp(rsp)
}

// TestUpstreamDNSWithBodyWithResponse request with arbitrary body returning *TestUpstreamDNSResp
func (c *ClientWithResponses) TestUpstreamDNSWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResp, error) {
	rsp, err := c.TestUpstreamDNSWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUpstreamDNSResp(rsp)
}

func (c *ClientWithResponses) TestUpstreamDNSWithResponse(ctx context.Context, body TestUpstreamDNSJSONRequestBody, reqEditors ...RequestEditorFn) (*TestUpstreamDNSResp, error) {
	rsp, err := c.TestUpstreamDNS(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestUpstreamDNSResp(rsp)
}

// TlsConfigureWithBodyWithResponse request with arbitrary body returning *TlsConfigureResp
func (c *ClientWithResponses) TlsConfigureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsConfigureResp, error) {
	rsp, err := c.TlsConfigureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsConfigureResp(rsp)
}

func (c *ClientWithResponses) TlsConfigureWithResponse(ctx context.Context, body TlsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsConfigureResp, error) {
	rsp, err := c.TlsConfigure(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsConfigureResp(rsp)
}

// TlsStatusWithResponse request returning *TlsStatusResp
func (c *ClientWithResponses) TlsStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TlsStatusResp, error) {
	rsp, err := c.TlsStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsStatusResp(rsp)
}

// TlsValidateWithBodyWithResponse request with arbitrary body returning *TlsValidateResp
func (c *ClientWithResponses) TlsValidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TlsValidateResp, error) {
	rsp, err := c.TlsValidateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsValidateResp(rsp)
}

func (c *ClientWithResponses) TlsValidateWithResponse(ctx context.Context, body TlsValidateJSONRequestBody, reqEditors ...RequestEditorFn) (*TlsValidateResp, error) {
	rsp, err := c.TlsValidate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTlsValidateResp(rsp)
}

// BeginUpdateWithResponse request returning *BeginUpdateResp
func (c *ClientWithResponses) BeginUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BeginUpdateResp, error) {
	rsp, err := c.BeginUpdate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeginUpdateResp(rsp)
}

// GetVersionJsonWithBodyWithResponse request with arbitrary body returning *GetVersionJsonResp
func (c *ClientWithResponses) GetVersionJsonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetVersionJsonResp, error) {
	rsp, err := c.GetVersionJsonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionJsonResp(rsp)
}

func (c *ClientWithResponses) GetVersionJsonWithResponse(ctx context.Context, body GetVersionJsonJSONRequestBody, reqEditors ...RequestEditorFn) (*GetVersionJsonResp, error) {
	rsp, err := c.GetVersionJson(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionJsonResp(rsp)
}

// ParseAccessListResp parses an HTTP response from a AccessListWithResponse call
func ParseAccessListResp(rsp *http.Response) (*AccessListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccessListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccessSetResp parses an HTTP response from a AccessSetWithResponse call
func ParseAccessSetResp(rsp *http.Response) (*AccessSetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccessSetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMobileConfigDoHResp parses an HTTP response from a MobileConfigDoHWithResponse call
func ParseMobileConfigDoHResp(rsp *http.Response) (*MobileConfigDoHResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MobileConfigDoHResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMobileConfigDoTResp parses an HTTP response from a MobileConfigDoTWithResponse call
func ParseMobileConfigDoTResp(rsp *http.Response) (*MobileConfigDoTResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MobileConfigDoTResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseBlockedServicesAllResp parses an HTTP response from a BlockedServicesAllWithResponse call
func ParseBlockedServicesAllResp(rsp *http.Response) (*BlockedServicesAllResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesAllResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesAll
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesScheduleResp parses an HTTP response from a BlockedServicesScheduleWithResponse call
func ParseBlockedServicesScheduleResp(rsp *http.Response) (*BlockedServicesScheduleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesScheduleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesListResp parses an HTTP response from a BlockedServicesListWithResponse call
func ParseBlockedServicesListResp(rsp *http.Response) (*BlockedServicesListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesAvailableServicesResp parses an HTTP response from a BlockedServicesAvailableServicesWithResponse call
func ParseBlockedServicesAvailableServicesResp(rsp *http.Response) (*BlockedServicesAvailableServicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesAvailableServicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockedServicesArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockedServicesSetResp parses an HTTP response from a BlockedServicesSetWithResponse call
func ParseBlockedServicesSetResp(rsp *http.Response) (*BlockedServicesSetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesSetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBlockedServicesScheduleUpdateResp parses an HTTP response from a BlockedServicesScheduleUpdateWithResponse call
func ParseBlockedServicesScheduleUpdateResp(rsp *http.Response) (*BlockedServicesScheduleUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockedServicesScheduleUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCacheClearResp parses an HTTP response from a CacheClearWithResponse call
func ParseCacheClearResp(rsp *http.Response) (*CacheClearResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheClearResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClientsStatusResp parses an HTTP response from a ClientsStatusWithResponse call
func ParseClientsStatusResp(rsp *http.Response) (*ClientsStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Clients
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClientsAddResp parses an HTTP response from a ClientsAddWithResponse call
func ParseClientsAddResp(rsp *http.Response) (*ClientsAddResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsAddResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClientsDeleteResp parses an HTTP response from a ClientsDeleteWithResponse call
func ParseClientsDeleteResp(rsp *http.Response) (*ClientsDeleteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsDeleteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClientsFindResp parses an HTTP response from a ClientsFindWithResponse call
func ParseClientsFindResp(rsp *http.Response) (*ClientsFindResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsFindResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientsFindResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClientsUpdateResp parses an HTTP response from a ClientsUpdateWithResponse call
func ParseClientsUpdateResp(rsp *http.Response) (*ClientsUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClientsUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDhcpAddStaticLeaseResp parses an HTTP response from a DhcpAddStaticLeaseWithResponse call
func ParseDhcpAddStaticLeaseResp(rsp *http.Response) (*DhcpAddStaticLeaseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpAddStaticLeaseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseCheckActiveDhcpResp parses an HTTP response from a CheckActiveDhcpWithResponse call
func ParseCheckActiveDhcpResp(rsp *http.Response) (*CheckActiveDhcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckActiveDhcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DhcpSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpInterfacesResp parses an HTTP response from a DhcpInterfacesWithResponse call
func ParseDhcpInterfacesResp(rsp *http.Response) (*DhcpInterfacesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpInterfacesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetInterfaces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDhcpRemoveStaticLeaseResp parses an HTTP response from a DhcpRemoveStaticLeaseWithResponse call
func ParseDhcpRemoveStaticLeaseResp(rsp *http.Response) (*DhcpRemoveStaticLeaseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpRemoveStaticLeaseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpResetResp parses an HTTP response from a DhcpResetWithResponse call
func ParseDhcpResetResp(rsp *http.Response) (*DhcpResetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpResetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpResetLeasesResp parses an HTTP response from a DhcpResetLeasesWithResponse call
func ParseDhcpResetLeasesResp(rsp *http.Response) (*DhcpResetLeasesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpResetLeasesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpSetConfigResp parses an HTTP response from a DhcpSetConfigWithResponse call
func ParseDhcpSetConfigResp(rsp *http.Response) (*DhcpSetConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpSetConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDhcpStatusResp parses an HTTP response from a DhcpStatusWithResponse call
func ParseDhcpStatusResp(rsp *http.Response) (*DhcpStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DhcpStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDhcpUpdateStaticLeaseResp parses an HTTP response from a DhcpUpdateStaticLeaseWithResponse call
func ParseDhcpUpdateStaticLeaseResp(rsp *http.Response) (*DhcpUpdateStaticLeaseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DhcpUpdateStaticLeaseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseDnsConfigResp parses an HTTP response from a DnsConfigWithResponse call
func ParseDnsConfigResp(rsp *http.Response) (*DnsConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDnsInfoResp parses an HTTP response from a DnsInfoWithResponse call
func ParseDnsInfoResp(rsp *http.Response) (*DnsInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DnsInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DNSConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilteringAddURLResp parses an HTTP response from a FilteringAddURLWithResponse call
func ParseFilteringAddURLResp(rsp *http.Response) (*FilteringAddURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringAddURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringCheckHostResp parses an HTTP response from a FilteringCheckHostWithResponse call
func ParseFilteringCheckHostResp(rsp *http.Response) (*FilteringCheckHostResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringCheckHostResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterCheckHostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilteringConfigResp parses an HTTP response from a FilteringConfigWithResponse call
func ParseFilteringConfigResp(rsp *http.Response) (*FilteringConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringRefreshResp parses an HTTP response from a FilteringRefreshWithResponse call
func ParseFilteringRefreshResp(rsp *http.Response) (*FilteringRefreshResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringRefreshResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterRefreshResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilteringRemoveURLResp parses an HTTP response from a FilteringRemoveURLWithResponse call
func ParseFilteringRemoveURLResp(rsp *http.Response) (*FilteringRemoveURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringRemoveURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringSetRulesResp parses an HTTP response from a FilteringSetRulesWithResponse call
func ParseFilteringSetRulesResp(rsp *http.Response) (*FilteringSetRulesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringSetRulesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringSetURLResp parses an HTTP response from a FilteringSetURLWithResponse call
func ParseFilteringSetURLResp(rsp *http.Response) (*FilteringSetURLResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringSetURLResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilteringStatusResp parses an HTTP response from a FilteringStatusWithResponse call
func ParseFilteringStatusResp(rsp *http.Response) (*FilteringStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilteringStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FilterStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangeLanguageResp parses an HTTP response from a ChangeLanguageWithResponse call
func ParseChangeLanguageResp(rsp *http.Response) (*ChangeLanguageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeLanguageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCurrentLanguageResp parses an HTTP response from a CurrentLanguageWithResponse call
func ParseCurrentLanguageResp(rsp *http.Response) (*CurrentLanguageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentLanguageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LanguageSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallCheckConfigResp parses an HTTP response from a InstallCheckConfigWithResponse call
func ParseInstallCheckConfigResp(rsp *http.Response) (*InstallCheckConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallCheckConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallConfigureResp parses an HTTP response from a InstallConfigureWithResponse call
func ParseInstallConfigureResp(rsp *http.Response) (*InstallConfigureResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallConfigureResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInstallGetAddressesResp parses an HTTP response from a InstallGetAddressesWithResponse call
func ParseInstallGetAddressesResp(rsp *http.Response) (*InstallGetAddressesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallGetAddressesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddressesInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResp parses an HTTP response from a LoginWithResponse call
func ParseLoginResp(rsp *http.Response) (*LoginResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogoutResp parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResp(rsp *http.Response) (*LogoutResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParentalDisableResp parses an HTTP response from a ParentalDisableWithResponse call
func ParseParentalDisableResp(rsp *http.Response) (*ParentalDisableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParentalDisableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParentalEnableResp parses an HTTP response from a ParentalEnableWithResponse call
func ParseParentalEnableResp(rsp *http.Response) (*ParentalEnableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParentalEnableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseParentalStatusResp parses an HTTP response from a ParentalStatusWithResponse call
func ParseParentalStatusResp(rsp *http.Response) (*ParentalStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ParentalStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Enable      *bool `json:"enable,omitempty"`
			Sensitivity *int  `json:"sensitivity,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProfileResp parses an HTTP response from a GetProfileWithResponse call
func ParseGetProfileResp(rsp *http.Response) (*GetProfileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProfileResp parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResp(rsp *http.Response) (*UpdateProfileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetProtectionResp parses an HTTP response from a SetProtectionWithResponse call
func ParseSetProtectionResp(rsp *http.Response) (*SetProtectionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetProtectionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryLogResp parses an HTTP response from a QueryLogWithResponse call
func ParseQueryLogResp(rsp *http.Response) (*QueryLogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryLogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetQueryLogConfigResp parses an HTTP response from a GetQueryLogConfigWithResponse call
func ParseGetQueryLogConfigResp(rsp *http.Response) (*GetQueryLogConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQueryLogConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetQueryLogConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutQueryLogConfigResp parses an HTTP response from a PutQueryLogConfigWithResponse call
func ParsePutQueryLogConfigResp(rsp *http.Response) (*PutQueryLogConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutQueryLogConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQuerylogClearResp parses an HTTP response from a QuerylogClearWithResponse call
func ParseQuerylogClearResp(rsp *http.Response) (*QuerylogClearResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QuerylogClearResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryLogConfigResp parses an HTTP response from a QueryLogConfigWithResponse call
func ParseQueryLogConfigResp(rsp *http.Response) (*QueryLogConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryLogConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueryLogInfoResp parses an HTTP response from a QueryLogInfoWithResponse call
func ParseQueryLogInfoResp(rsp *http.Response) (*QueryLogInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryLogInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryLogConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRewriteAddResp parses an HTTP response from a RewriteAddWithResponse call
func ParseRewriteAddResp(rsp *http.Response) (*RewriteAddResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteAddResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRewriteDeleteResp parses an HTTP response from a RewriteDeleteWithResponse call
func ParseRewriteDeleteResp(rsp *http.Response) (*RewriteDeleteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteDeleteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRewriteListResp parses an HTTP response from a RewriteListWithResponse call
func ParseRewriteListResp(rsp *http.Response) (*RewriteListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RewriteList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRewriteUpdateResp parses an HTTP response from a RewriteUpdateWithResponse call
func ParseRewriteUpdateResp(rsp *http.Response) (*RewriteUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RewriteUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafebrowsingDisableResp parses an HTTP response from a SafebrowsingDisableWithResponse call
func ParseSafebrowsingDisableResp(rsp *http.Response) (*SafebrowsingDisableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafebrowsingDisableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafebrowsingEnableResp parses an HTTP response from a SafebrowsingEnableWithResponse call
func ParseSafebrowsingEnableResp(rsp *http.Response) (*SafebrowsingEnableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafebrowsingEnableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafebrowsingStatusResp parses an HTTP response from a SafebrowsingStatusWithResponse call
func ParseSafebrowsingStatusResp(rsp *http.Response) (*SafebrowsingStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafebrowsingStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Enabled *bool `json:"enabled,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSafesearchDisableResp parses an HTTP response from a SafesearchDisableWithResponse call
func ParseSafesearchDisableResp(rsp *http.Response) (*SafesearchDisableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchDisableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafesearchEnableResp parses an HTTP response from a SafesearchEnableWithResponse call
func ParseSafesearchEnableResp(rsp *http.Response) (*SafesearchEnableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchEnableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafesearchSettingsResp parses an HTTP response from a SafesearchSettingsWithResponse call
func ParseSafesearchSettingsResp(rsp *http.Response) (*SafesearchSettingsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchSettingsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSafesearchStatusResp parses an HTTP response from a SafesearchStatusWithResponse call
func ParseSafesearchStatusResp(rsp *http.Response) (*SafesearchStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SafesearchStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SafeSearchConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatsResp parses an HTTP response from a StatsWithResponse call
func ParseStatsResp(rsp *http.Response) (*StatsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatsConfigResp parses an HTTP response from a GetStatsConfigWithResponse call
func ParseGetStatsConfigResp(rsp *http.Response) (*GetStatsConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStatsConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutStatsConfigResp parses an HTTP response from a PutStatsConfigWithResponse call
func ParsePutStatsConfigResp(rsp *http.Response) (*PutStatsConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutStatsConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatsConfigResp parses an HTTP response from a StatsConfigWithResponse call
func ParseStatsConfigResp(rsp *http.Response) (*StatsConfigResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsConfigResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatsInfoResp parses an HTTP response from a StatsInfoWithResponse call
func ParseStatsInfoResp(rsp *http.Response) (*StatsInfoResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsInfoResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatsResetResp parses an HTTP response from a StatsResetWithResponse call
func ParseStatsResetResp(rsp *http.Response) (*StatsResetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsResetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStatusResp parses an HTTP response from a StatusWithResponse call
func ParseStatusResp(rsp *http.Response) (*StatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTestUpstreamDNSResp parses an HTTP response from a TestUpstreamDNSWithResponse call
func ParseTestUpstreamDNSResp(rsp *http.Response) (*TestUpstreamDNSResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestUpstreamDNSResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpstreamsConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTlsConfigureResp parses an HTTP response from a TlsConfigureWithResponse call
func ParseTlsConfigureResp(rsp *http.Response) (*TlsConfigureResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TlsConfigureResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTlsStatusResp parses an HTTP response from a TlsStatusWithResponse call
func ParseTlsStatusResp(rsp *http.Response) (*TlsStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TlsStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTlsValidateResp parses an HTTP response from a TlsValidateWithResponse call
func ParseTlsValidateResp(rsp *http.Response) (*TlsValidateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TlsValidateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBeginUpdateResp parses an HTTP response from a BeginUpdateWithResponse call
func ParseBeginUpdateResp(rsp *http.Response) (*BeginUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BeginUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVersionJsonResp parses an HTTP response from a GetVersionJsonWithResponse call
func ParseGetVersionJsonResp(rsp *http.Response) (*GetVersionJsonResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionJsonResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
